<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Focus Time Tracker</title>
    <!-- Favicon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>‚è≤Ô∏è</text></svg>">

    <!-- Apple Touch Icon -->
    <link rel="apple-touch-icon" href="icons/icon-512x512.png">
    
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js CDN for charts -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap');
        body { font-family: 'Inter', sans-serif; background-color: #f3f4f6; }
        .container { max-width: 1200px; margin: 2rem auto; padding: 2rem; background-color: #ffffff; border-radius: 0.75rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
        .btn { padding: 0.75rem 1.5rem; border-radius: 0.5rem; font-weight: 600; transition: all 0.2s ease-in-out; border: none; cursor: pointer; }
        .btn:disabled { background-color: #d1d5db; color: #6b7280; cursor: not-allowed; }
        .btn-green { background-color: #10B981; color: white; }
        .btn-green:hover:not(:disabled) { background-color: #059669; }
        .btn-red { background-color: #EF4444; color: white; }
        .btn-red:hover:not(:disabled) { background-color: #DC2626; }
        .btn-blue { background-color: #3B82F6; color: white; }
        .btn-blue:hover:not(:disabled) { background-color: #2563EB; }
        .btn-orange { background-color: #F97316; color: white; }
        .btn-orange:hover:not(:disabled) { background-color: #EA580C; }
        .btn-yellow { background-color: #F59E0B; color: white; }
        .btn-yellow:hover:not(:disabled) { background-color: #D97706; }
        .btn-gray { background-color: #4B5563; color: white; }
        .btn-gray:hover:not(:disabled) { background-color: #374151; }
        .view-btn { padding: 0.5rem 1rem; border-radius: 0.5rem; font-size: 0.875rem; font-weight: 500; background-color: #E5E7EB; color: #374151; transition: background-color 0.2s ease-in-out; }
        .view-btn.active { background-color: #3B82F6; color: white; }
        .view-btn:hover:not(.active) { background-color: #D1D5DB; }
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5); align-items: center; justify-content: center; }
        .modal-content { background-color: #fefefe; margin: auto; padding: 2rem; border-radius: 0.75rem; width: 90%; max-width: 500px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15); max-height: 90vh; overflow-y: auto; }
        .close-button { color: #aaa; float: right; font-size: 28px; font-weight: bold; line-height: 1; }
        .close-button:hover, .close-button:focus { color: black; text-decoration: none; cursor: pointer; }
        .log-entry-item { background-color: #f8f8f8; border: 1px solid #e5e7eb; border-radius: 0.5rem; padding: 0.75rem; margin-bottom: 0.5rem; display: flex; flex-direction: column; gap: 0.5rem; }
        @media (min-width: 640px) { .log-entry-item { flex-direction: row; justify-content: space-between; align-items: center; } }
        .toggle-checkbox { position: absolute; display: block; width: 1.5rem; height: 1.5rem; border-radius: 9999px; background-color: white; border: 4px solid transparent; -webkit-appearance: none; -moz-appearance: none; appearance: none; cursor: pointer; transition: transform 0.2s ease-in-out, border-color 0.2s ease-in-out; left: 0; }
        .toggle-checkbox:checked { border-color: #10B981; transform: translateX(1rem); }
        .toggle-label { display: block; overflow: hidden; height: 1.5rem; border-radius: 9999px; background-color: #D1D5DB; cursor: pointer; transition: background-color 0.2s ease-in-out; }
        .toggle-checkbox:checked + .toggle-label { background-color: #10B981; }
        .calendar-day { transition: all 0.2s ease-in-out; border: 2px solid transparent; }
        .calendar-day:hover { transform: scale(1.05); box-shadow: 0 0 10px rgba(59, 130, 246, 0.5); }
        .day-off-explicit { background-color: #fca5a5 !important; color: #b91c1c; font-weight: bold; border-color: #ef4444; }
        .today { border: 2px solid #3B82F6; }
        .star-rating .fa-star { color: #e5e7eb; cursor: pointer; transition: color 0.2s; font-size: 1.5rem; }
        #reflectionModal .star-rating .fa-star, #editLogModal .star-rating .fa-star { font-size: 2rem; }
        .star-rating .fa-star.hover, .star-rating .fa-star.selected { color: #f59e0b; }
        .log-star { font-size: 0.8rem; color: #f59e0b;}
        .timeline-container { position: relative; padding-bottom: 20px; }
        .timeline { position: relative; width: 100%; height: 8px; background-color: #e5e7eb; border-radius: 4px; margin-top: 0.5rem; }
        .timeline-segment { position: absolute; top: 0; height: 100%; }
        .timeline-focus { background-color: #A7F3D0; }
        .timeline-manual { background-color: #93C5FD; }
        .timeline-break { background-color: rgba(16, 185, 129, 0.4); border-left: 2px solid #059669; border-right: 2px solid #059669; }
        .timeline-penalty { background-color: rgba(239, 68, 68, 0.6); }
        .timeline-dot { position: absolute; top: 50%; width: 12px; height: 12px; background-color: #ef4444; border-radius: 50%; transform: translateY(-50%); border: 2px solid white; box-shadow: 0 0 5px rgba(0,0,0,0.2); z-index: 3; }
        .timeline-marker { position: absolute; top: 16px; transform: translateX(-50%); font-size: 10px; color: #6b7280; }
        
        /* Daily Timeline Specifics */
        .daily-timeline-wrapper { height: 40px; background: #f9fafb; border-radius: 6px; position: relative; overflow: hidden; border: 1px solid #e5e7eb; }
        .daily-timeline-bar { height: 100%; position: absolute; top: 0; transition: all 0.3s ease; }
        .daily-timeline-hour-marker { position: absolute; top: 0; bottom: 0; border-left: 1px dashed #d1d5db; font-size: 9px; color: #9ca3af; padding-left: 2px; }

        .info-tooltip-container { position: relative; display: inline-block; }
        .info-tooltip-text { visibility: hidden; width: 220px; background-color: #555; color: #fff; text-align: center; border-radius: 6px; padding: 5px 10px; position: absolute; z-index: 10; bottom: 125%; left: 50%; margin-left: -110px; opacity: 0; transition: opacity 0.3s; font-size: 0.75rem; line-height: 1.25rem; }
        .info-tooltip-container:hover .info-tooltip-text { visibility: visible; opacity: 1; }
        @media (max-width: 475px) {
            #timeValue { font-size: 2.5rem; line-height: 1; }
        }
		/* Daily Timeline Specifics */
		.daily-timeline-wrapper { 
			height: 40px; 
			background: #f9fafb; 
			border-radius: 6px; 
			position: relative; 
			overflow: hidden; 
			border: 1px solid #e5e7eb; 
		}
		.daily-timeline-marker-line {
			position: absolute;
			top: 0;
			bottom: 0;
			border-left: 1px dashed #d1d5db;
			z-index: 1;
			pointer-events: none;
		}
		.daily-timeline-marker-label {
			position: absolute;
			top: -18px; /* Move label above the bar */
			transform: translateX(-50%);
			font-size: 10px;
			color: #6b7280;
			white-space: nowrap;
		}
		.daily-timeline-segment {
			position: absolute;
			height: 100%;
			top: 0;
			z-index: 2; /* Ensure segments are above grid lines */
			transition: all 0.2s ease;
		}
		.daily-timeline-segment:hover {
			z-index: 10;
			filter: brightness(0.95);
		}
		.timeline-focus-segment { background-color: #A7F3D0; border-left: 1px solid #059669; border-right: 1px solid #059669; }
		.timeline-manual-segment { background-color: #93C5FD; border-left: 1px solid #2563EB; border-right: 1px solid #2563EB; }
		.timeline-break-segment { 
			background-color: rgba(255, 255, 255, 0.5); 
			background-image: repeating-linear-gradient(45deg, #e5e7eb 0, #e5e7eb 5px, transparent 5px, transparent 10px);
			border-top: 1px dashed #059669;
			border-bottom: 1px dashed #059669;
		}
		.timeline-penalty-segment { background-color: #FCA5A5; border-left: 1px solid #DC2626; border-right: 1px solid #DC2626; }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">
    <div class="container bg-white rounded-xl shadow-lg p-8 w-full">
        <!-- Header -->
        <div class="w-full flex justify-between items-center mb-6">
            <div class="flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-clock text-blue-600 mr-3"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
                <h1 class="text-2xl md:text-4xl font-bold text-gray-800">Focus Time Tracker</h1>
            </div>
            <div id="authContainer" class="flex items-center space-x-3"></div>
        </div>
        
        <!-- Loading Message -->
        <div id="loadingMessage" class="text-xl text-gray-700 text-center py-10">Initializing...</div>
        
        <!-- Main App Section -->
        <div id="appSection" class="w-full hidden">
            <!-- Timer Controls -->
            <div class="bg-white rounded-lg shadow-md p-6 text-center border border-gray-200 mb-8">
                <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                    <div class="md:col-span-2">
                        <!-- Timer Mode Buttons -->
                        <div class="flex justify-center space-x-4 mb-4">
                            <button id="stopwatchModeBtn" class="timer-mode-btn view-btn active">Ad-hoc Focus</button>
                            <button id="countdownModeBtn" class="timer-mode-btn view-btn">Focus Session</button>
                        </div>
                        <!-- Timer Display -->
                        <div id="timerDisplayContainer" class="text-center">
                            <div id="timerDisplay" class="flex flex-col justify-center text-6xl font-extrabold text-blue-600 p-4 bg-blue-50 rounded-lg h-36">
                                <p id="timerModeDescription" class="text-gray-500 text-xs font-semibold uppercase tracking-wider mb-3">Stopwatch</p>
                                <span id="timeValue">00:00:00</span>
                            </div>
                             <div id="nextBreakCountdown" class="text-md text-gray-500 hidden h-6 mt-2"></div>
                             <div id="breakTimerDisplay" class="text-lg font-bold text-gray-600 hidden h-6 mt-2"></div>
                             <div id="breakActivitySuggestion" class="text-md text-blue-600 hidden h-6 mt-2"></div>
                        </div>
                        <!-- Timer Action Buttons -->
                        <div class="flex justify-center items-center space-x-4 mt-4">
                            <button id="togglePauseBtn" class="btn btn-green shadow-md">Start Focusing</button>
                            <button id="endFocusBtn" class="btn btn-red shadow-md">End Focusing</button>
                        </div>
                    </div>
                    <!-- Interruptions and Toggles -->
                    <div class="flex flex-col justify-between space-y-6">
                        <div class="p-4 bg-yellow-50 rounded-lg shadow-inner h-full flex flex-col justify-center items-center">
                            <h3 class="text-lg font-semibold text-yellow-800 mb-2">Interruptions</h3>
                            <p class="text-3xl font-bold text-yellow-900 mb-3" id="sessionInterruptionsDisplay">0</p>
                            <button id="logInterruptionBtn" class="btn btn-yellow w-full" disabled>Log Interruption</button>
                        </div>
                        <div class="flex justify-around items-center pt-4 border-t">
                            <div class="flex items-center space-x-3">
                                <label for="notificationToggle" class="text-gray-700 font-medium">Reminders</label>
                                <div class="relative inline-block w-10 align-middle select-none">
                                    <input type="checkbox" name="notificationToggle" id="notificationToggle" class="toggle-checkbox"/>
                                    <label for="notificationToggle" class="toggle-label"></label>
                                </div>
                            </div>
                            <div class="flex items-center space-x-3">
                                <label for="focusMusicToggle" class="text-gray-700 font-medium">Music</label>
                                <div class="relative inline-block w-10 align-middle select-none">
                                    <input type="checkbox" name="focusMusicToggle" id="focusMusicToggle" class="toggle-checkbox"/>
                                    <label for="focusMusicToggle" class="toggle-label"></label>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- KPI Dashboard -->
            <div class="w-full p-6 bg-purple-50 rounded-lg shadow-inner mb-8">
                 <div class="grid grid-cols-1 sm:grid-cols-3 items-center mb-6 gap-4">
                    <div class="sm:col-start-2 text-center">
                         <h2 id="kpiDashboardTitle" class="text-2xl font-semibold text-purple-700">KPI Dashboard</h2>
                    </div>
                    <div class="sm:col-start-3 flex sm:justify-end">
                        <button id="openGoalsModalBtn" class="btn btn-blue w-full sm:w-auto">Set Goals</button>
                    </div>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
                    <div class="bg-white p-4 rounded-lg shadow-sm text-center"><h3 class="font-semibold text-gray-600">Focus Time</h3><p id="todayProgressText" class="text-2xl font-bold text-blue-600 my-2">0 / 0 min</p><div class="w-full bg-gray-200 rounded-full h-2.5"><div id="todayProgressBar" class="bg-blue-600 h-2.5 rounded-full" style="width: 0%; transition: width 0.5s;"></div></div></div>
                    <div class="bg-white p-4 rounded-lg shadow-sm text-center"><h3 class="font-semibold text-gray-600">Focus Sessions</h3><p id="sessionsProgressText" class="text-2xl font-bold text-green-600 my-2">0 / 0</p><div class="w-full bg-gray-200 rounded-full h-2.5"><div id="sessionsProgressBar" class="bg-green-500 h-2.5 rounded-full" style="width: 0%; transition: width 0.5s;"></div></div></div>
                    <div class="bg-white p-4 rounded-lg shadow-sm text-center"><h3 class="font-semibold text-gray-600">Mins/Interruption</h3><div id="minsPerInterruptionContainer" class="flex items-center justify-center my-2"><p id="minsPerInterruptionText" class="text-2xl font-bold text-red-500">0 min</p></div>
                        <div class="text-xs text-gray-500 flex flex-col sm:flex-row sm:justify-center sm:items-center">
                            <span class="mr-1">Max Uninterrupted Focus:</span>
                            <span id="maxFocusText">0 min</span>
                        </div>
                    </div>
                    <div class="bg-white p-4 rounded-lg shadow-sm text-center"><h3 class="font-semibold text-gray-600">Focus Streak</h3><div class="flex items-center justify-center my-2"><div class="text-4xl mr-2">üî•</div><p id="streakText" class="text-2xl font-bold text-orange-500">0 Days</p></div><p class="text-xs text-gray-500">Consecutive days meeting your goal</p></div>
                </div>
            </div>
            
            <!-- Timeline Visualization -->
			<div class="w-full p-6 bg-white rounded-lg shadow-sm mb-8 border border-gray-200">
				<div class="flex flex-col md:flex-row justify-between items-center mb-4 gap-3 md:gap-0">
					<h3 class="text-lg font-semibold text-gray-700 w-full md:w-auto text-center md:text-left">Daily Timeline</h3>
					<div class="flex items-center justify-center space-x-2 w-full md:w-auto">
						 <button id="tlJumpTodayBtn" class="mr-2 text-xs bg-blue-50 text-blue-600 px-2 py-1 rounded hover:bg-blue-100 transition-colors">Jump to Today</button>
						 
						 <button id="tlPrevDay" class="text-gray-500 hover:text-blue-600 p-1"><i class="fa-solid fa-chevron-left"></i></button>
						 <span id="tlDateDisplay" class="text-sm font-medium text-gray-600 w-32 text-center">Today</span>
						 <button id="tlNextDay" class="text-gray-500 hover:text-blue-600 p-1 disabled:opacity-30"><i class="fa-solid fa-chevron-right"></i></button>
					</div>
				</div>
				
				<div class="relative w-full mt-6 mb-2">
					<div id="dailyTimelineMarkers" class="relative w-full h-4 text-xs text-gray-400 mb-1"></div>
					
					<div id="dailyTimeline" class="daily-timeline-wrapper h-10 bg-gray-50 rounded-md relative overflow-hidden border border-gray-200" title="Green: Focus | Blue: Manual | Red: Penalty | Dashed: Break">
						</div>
				</div>

				<div class="flex flex-wrap gap-4 mt-2 text-xs text-gray-500 justify-center">
					<div class="flex items-center"><div class="w-3 h-3 bg-green-200 border border-green-500 mr-1 rounded-sm"></div> Focus</div>
					<div class="flex items-center"><div class="w-3 h-3 bg-blue-300 border border-blue-500 mr-1 rounded-sm"></div> Manual</div>
					<div class="flex items-center"><div class="w-3 h-3 bg-red-400 border border-red-500 mr-1 rounded-sm"></div> Penalty</div>
					<div class="flex items-center"><div class="w-3 h-3 bg-white border border-green-500 border-dashed mr-1 rounded-sm"></div> Break</div>
				</div>
			</div>

            <!-- Stats Chart -->
            <div class="w-full p-6 bg-yellow-50 rounded-lg shadow-inner mb-8">
                <h2 class="text-2xl font-semibold text-yellow-700 mb-4 text-center flex justify-center items-center gap-2">
                    <span>Focus Time Stats</span>
                    <span id="chartInfoIconContainer"></span>
                </h2>
                <!-- Chart Controls -->
                <div class="flex flex-col sm:flex-row justify-center items-center gap-4 mb-6">
                    <select id="chartTypeSelect" class="p-2 rounded-md border-gray-300 shadow-sm">
                        <optgroup label="Focus Time">
                            <option value="avgDailyFocusTime">Avg Daily Focus Time</option>
                            <option value="totalFocusTime">Total Focus Time</option>
                        </optgroup>
                        <optgroup label="Focus Sessions">
                             <option value="completedSessions">Completed Sessions vs. Goal</option>
                        </optgroup>
                        <optgroup label="Focus Quality">
                             <option value="avgQuality">Avg Focus Quality Rating</option>
                             <option value="reasonBubbleChart">Reasons for Low Quality</option>
                        </optgroup>
                        <optgroup label="Interruptions">
                            <option value="minsPerInterruption">Avg Mins per Interruption</option>
                            <option value="interruptionLikelihood">Interruption Rate</option>
                        </optgroup>
                    </select>
                    <!-- Default Day/Week/Month Controls -->
                    <div id="chartViewControls" class="flex space-x-2">
                        <button id="viewDay" class="view-btn active">Day</button>
                        <button id="viewWeek" class="view-btn">Week</button>
                        <button id="viewMonth" class="view-btn">Month</button>
                        <button id="viewYear" class="view-btn">Year</button>
                    </div>
                    <!-- Controls for Interruption Rate Chart -->
                     <div id="comparisonControls" class="hidden flex-wrap items-center justify-center gap-4">
                        <div class="flex items-center gap-2 p-2 bg-gray-100 rounded-lg">
                            <label for="range1Start" class="font-semibold text-sm text-gray-600">Period 1:</label>
                            <input type="date" id="range1Start" class="p-1 border rounded-md text-sm">
                            <span class="text-gray-500">-</span>
                            <input type="date" id="range1End" class="p-1 border rounded-md text-sm">
                        </div>
                        <div class="flex items-center gap-2">
                            <input type="checkbox" id="compareToggle" class="h-4 w-4 rounded border-gray-300">
                            <label for="compareToggle" class="text-sm font-medium text-gray-700">Compare</label>
                        </div>
                        <div id="period2Container" class="hidden items-center gap-2 p-2 bg-gray-100 rounded-lg">
                            <label for="range2Start" class="font-semibold text-sm text-gray-600">Period 2:</label>
                            <input type="date" id="range2Start" class="p-1 border rounded-md text-sm">
                            <span class="text-gray-500">-</span>
                            <input type="date" id="range2End" class="p-1 border rounded-md text-sm">
                        </div>
                    </div>
                    <!-- Controls for Reason Chart -->
                    <div id="reasonChartControls" class="hidden flex-wrap items-center justify-center gap-4">
                        <div class="flex items-center gap-2 p-2 bg-gray-100 rounded-lg">
                            <label for="reasonRangeStart" class="font-semibold text-sm text-gray-600">Start Date:</label>
                            <input type="date" id="reasonRangeStart" class="p-1 border rounded-md text-sm">
                            <span class="text-gray-500">-</span>
                             <label for="reasonRangeEnd" class="font-semibold text-sm text-gray-600">End Date:</label>
                            <input type="date" id="reasonRangeEnd" class="p-1 border rounded-md text-sm">
                        </div>
                    </div>
                </div>
                <!-- Chart Canvas -->
                <div class="relative h-80 w-full"><canvas id="timeChart"></canvas></div>
            </div>

            <!-- Log and Calendar Section -->
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-8 mt-10">
                <!-- Log -->
                <div class="lg:col-span-2 w-full p-6 bg-blue-50 rounded-lg shadow-inner">
                    <!-- Manual Entry -->
                    <div class="mb-6 p-4 border border-blue-200 rounded-lg">
                        <h3 class="text-xl font-medium text-blue-600 mb-3">Add New Focus Entry</h3>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div><label for="newEntryDate" class="block text-sm font-medium text-gray-700">Date</label><input type="date" id="newEntryDate" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2"></div>
                             <div class="flex space-x-2">
                                <div class="flex-1">
                                    <label for="newEntryStartTime" class="block text-sm font-medium text-gray-700">Start</label>
                                    <input type="time" id="newEntryStartTime" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2">
                                </div>
                                <div class="flex-1">
                                    <label for="newEntryEndTime" class="block text-sm font-medium text-gray-700">End</label>
                                    <input type="time" id="newEntryEndTime" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2">
                                </div>
                            </div>
                             <div class="flex space-x-2">
                                <div class="flex-1"><label for="newEntryHours" class="block text-sm font-medium text-gray-700">Hours</label><input type="number" id="newEntryHours" min="0" value="0" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2"></div>
                                <div class="flex-1"><label for="newEntryMinutes" class="block text-sm font-medium text-gray-700">Minutes</label><input type="number" id="newEntryMinutes" min="0" max="59" value="0" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2"></div>
                            </div>
                            <div><label for="newEntryInterruptions" class="block text-sm font-medium text-gray-700">Interruptions (optional)</label><input type="number" id="newEntryInterruptions" min="0" placeholder="0" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2"></div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Quality (optional)</label>
                                <div class="star-rating flex items-center mt-2" data-rating="0" id="newEntryStarRating">
                                    <i class="fa-solid fa-star" data-value="1"></i><i class="fa-solid fa-star" data-value="2"></i><i class="fa-solid fa-star" data-value="3"></i><i class="fa-solid fa-star" data-value="4"></i><i class="fa-solid fa-star" data-value="5"></i>
                                </div>
                            </div>
                        </div>
                        <button id="addEntryBtn" class="btn btn-blue mt-4 w-full">Add Entry</button>
                    </div>
                    <!-- Log Entries -->
                    <h2 class="text-2xl font-semibold text-blue-700 mb-4 text-center">Focus Time Log</h2>
                    <div id="logEntries" class="space-y-3"><p class="text-center text-gray-500">No entries yet.</p></div>
                    <button id="showMoreLogBtn" class="text-blue-600 hover:text-blue-800 font-medium py-2 px-4 rounded-md w-full mt-4 hidden">Show More</button>
                </div>
                <!-- Calendar -->
                <div class="p-6 bg-red-50 rounded-lg shadow-inner">
                    <h2 class="text-xl font-bold text-red-700 mb-4">Manage Days Off</h2>
                    <div class="flex justify-between items-center mb-4">
                        <button id="prevMonthBtn" class="p-2 rounded-full hover:bg-gray-200"><</button>
                        <h3 id="calendarMonthYear" class="text-lg font-semibold"></h3>
                        <button id="nextMonthBtn" class="p-2 rounded-full hover:bg-gray-200">></button>
                    </div>
                    <div id="calendarGrid" class="grid grid-cols-7 gap-1 text-center"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modals -->
    <!-- Auth Modal -->
    <div id="authModal" class="modal">
        <div class="modal-content">
            <span id="closeAuthModalBtn" class="close-button">√ó</span>
            <h2 class="text-3xl font-bold text-gray-800 mb-4 text-center">Welcome!</h2>
            <p class="text-gray-600 mb-6 text-center">Sign in or create an account to save your progress.</p>
            <input type="email" id="authEmail" placeholder="Email" class="w-full p-3 mb-4 border border-gray-300 rounded-lg"/>
            <input type="password" id="authPassword" placeholder="Password" class="w-full p-3 mb-6 border border-gray-300 rounded-lg"/>
            <p id="authErrorMessage" class="text-red-500 mb-4 text-center h-5"></p>
            <div class="flex flex-col space-y-3">
                <div class="flex space-x-3 w-full">
                    <button id="signInBtn" class="flex-1 btn btn-blue">Sign In</button>
                    <button id="createAccountBtn" class="flex-1 btn btn-green">Create Account</button>
                </div>
                <button id="anonymousSignInBtn" class="w-full btn bg-gray-600 hover:bg-gray-700 text-white">Continue Anonymously</button>
            </div>
        </div>
    </div>
    <!-- Generic Message Modal -->
    <div id="messageModal" class="modal"><div class="modal-content"><span class="close-button">√ó</span><p id="modalMessage" class="text-gray-700 text-lg"></p><div class="mt-4 flex justify-end"><button id="modalOkBtn" class="btn btn-blue">OK</button></div></div></div>
    <!-- Generic Confirm Modal -->
    <div id="confirmModal" class="modal"><div class="modal-content"><p id="confirmMessage" class="text-gray-700 text-lg"></p><div class="mt-4 flex justify-end space-x-2"><button id="confirmCancelBtn" class="btn btn-red">Cancel</button><button id="confirmOkBtn" class="btn btn-blue">Confirm</button></div></div></div>
    <!-- Countdown Setup Modal -->
    <div id="countdownModal" class="modal"><div class="modal-content"><h3 class="text-xl font-bold mb-4">Preparation</h3><div class="space-y-4"><div><label for="countdownMinutes" class="block text-sm font-medium">Focus Session Duration (minutes)</label><input type="number" id="countdownMinutes" min="1" value="25" class="mt-1 block w-full p-2 border rounded-md"><p id="countdownError" class="text-xs text-gray-500 h-4 mt-1"></p></div><div><label for="breakIntervalMinutes" class="block text-sm font-medium">Notify for break every (minutes, optional)</label><input type="number" id="breakIntervalMinutes" min="1" class="mt-1 block w-full p-2 border rounded-md"></div><div class="p-2 bg-gray-100 rounded-md"><h4 class="text-sm font-medium text-gray-800 mb-1">My Ritual</h4><p id="ritualText" class="text-sm text-gray-600 whitespace-pre-wrap"></p></div></div><div class="mt-6 flex justify-end space-x-3"><button id="cancelCountdownBtn" class="btn bg-gray-300">Cancel</button><button id="startCountdownBtn" class="btn btn-blue">Start</button></div></div></div>
    <!-- Countdown Complete (Medal) Modal -->
    <div id="medalModal" class="modal"><div class="modal-content text-center"><div class="text-8xl mb-4">üèÖ</div><h3 class="text-2xl font-bold text-yellow-500 mb-2">Focus Session Complete!</h3><p class="text-gray-600">You can reflect now or continue focusing. Your overtime will be tracked.</p><div id="overtimeDisplay" class="text-3xl mt-4 font-bold text-gray-700">00:00:00</div><div class="mt-4"><input type="checkbox" id="addOvertimeCheckbox" class="h-4 w-4 rounded border-gray-300" checked><label for="addOvertimeCheckbox" class="ml-2 text-gray-700">Add overtime to session</label></div><div class="mt-6"><button id="closeMedalModalBtn" class="btn btn-blue w-full">Reflect on Session</button></div></div></div>
    <!-- Pause Prompt Modal -->
    <div id="interruptionPromptModal" class="modal"><div class="modal-content"><h3 class="text-xl font-bold mb-4">Pausing Focus</h3><p class="mb-4">Did an interruption cause you to pause?</p><div class="mt-6 flex justify-between items-center"><button id="justPauseBtn" class="btn bg-gray-400">Just Pause</button><button id="logInterruptionFromPauseBtn" class="btn btn-yellow">Log Interruption & Pause</button></div><button id="cancelPauseBtn" class="btn bg-gray-200 text-gray-800 w-full mt-4">Nevermind</button></div></div></div>
    <!-- Log Interruption Modal -->
    <div id="logInterruptionModal" class="modal"><div class="modal-content"><h3 class="text-xl font-bold mb-4">Log an Interruption</h3><div><label for="penaltyMinutesInput">Penalty Minutes (subtracted from timer)</label><input type="number" id="penaltyMinutesInput" min="0" value="5" class="mt-1 block w-full p-2 border rounded-md"><p id="penaltyErrorStatus" class="text-xs text-gray-500 h-4 mt-1"></p></div><div class="mt-6 flex justify-end space-x-3"><button id="cancelLogInterruptionBtn" class="btn bg-gray-300">Cancel</button><button id="confirmLogInterruptionBtn" class="btn btn-yellow">Log It</button></div></div></div>
    <!-- Reflection Modal -->
    <div id="reflectionModal" class="modal"><div class="modal-content"><h3 class="text-xl font-bold mb-4">Reflection</h3><div id="reflectionTimelineContainer" class="timeline-container" title="This timeline shows when interruptions occurred during your session."><div id="reflectionTimeline" class="timeline"></div></div><p id="reflectionSuggestionText" class="text-sm text-gray-600 mb-4"></p><div class="mb-4"><label class="block text-sm font-medium text-gray-700 mb-2">Focus Quality</label><div class="star-rating flex justify-center" data-rating="0"><i class="fa-solid fa-star" data-value="1"></i><i class="fa-solid fa-star" data-value="2"></i><i class="fa-solid fa-star" data-value="3"></i><i class="fa-solid fa-star" data-value="4"></i><i class="fa-solid fa-star" data-value="5"></i></div></div><div class="mt-6 flex justify-end"><button id="confirmReflectionBtn" class="btn btn-red">Next</button></div></div></div>
    <!-- Goals Modal -->
    <div id="goalsModal" class="modal"><div class="modal-content"><span class="close-button">√ó</span><h2 class="text-xl font-bold mb-4">Set Goals</h2><div class="space-y-4"><div><label for="todayFocusGoal">Today‚Äôs Focus Time (min)</label><input type="number" id="todayFocusGoal" min="0" class="mt-1 block w-full p-2 border rounded-md"><p id="todayFocusGoalError" class="text-xs text-gray-500 h-4 mt-1"></p></div><div><label for="scheduledSessionsGoal">Scheduled Focus Sessions</label><input type="number" id="scheduledSessionsGoal" min="0" class="mt-1 block w-full p-2 border rounded-md"><p id="scheduledSessionsGoalError" class="text-xs text-gray-500 h-4 mt-1"></p></div><div><label for="interruptionGoal">Mins per Interruption Goal</label><input type="number" id="interruptionGoal" min="0" class="mt-1 block w-full p-2 border rounded-md"><p id="interruptionGoalError" class="text-xs text-gray-500 h-4 mt-1"></p></div></div><button id="saveGoalsBtn" class="btn btn-blue mt-6 w-full">Save Goals</button></div></div></div>
    <!-- Edit Log Entry Modal -->
    <div id="editLogModal" class="modal"></div>
    <!-- Low Quality Reason Modal -->
    <div id="reasonModal" class="modal"><div class="modal-content"><h3 class="text-xl font-bold mb-4">Reason for Low Quality</h3><p class="text-sm text-gray-600 mb-4">Select a past reason or add a new one.</p><div id="pastReasonsContainer" class="flex flex-wrap gap-2 mb-4"></div><input type="text" id="newReasonInput" placeholder="New reason (e.g., Low Energy)" class="w-full p-2 border rounded-md"><div class="mt-6 flex justify-end"><button id="saveReasonBtn" class="btn btn-blue">Save & Continue</button></div></div></div>
    <!-- Improvement Modal -->
    <div id="improvementModal" class="modal"><div class="modal-content"><h3 class="text-xl font-bold mb-4">Self-Reflection</h3><p class="text-sm text-gray-600 mb-4">How could you improve this next time?</p><textarea id="improvementText" rows="3" class="w-full p-2 border rounded-md"></textarea><div class="mt-6 flex justify-end"><button id="finishReflectionBtn" class="btn btn-green">Finish</button></div></div></div>
    <!-- Ad-hoc (Stopwatch) Reflection Prompt -->
    <div id="adhocReflectionModal" class="modal"><div class="modal-content"><h3 class="text-xl font-bold mb-4">Session Ended</h3><p class="text-gray-600 mb-6">How would you like to proceed?</p><div class="flex flex-col space-y-3"><button id="adhocReflectBtn" class="btn btn-blue">Reflect on Session</button><button id="adhocSkipBtn" class="btn bg-gray-300 text-gray-800">Save & Skip Reflection</button></div></div></div>
    <!-- Early End (Countdown) Modal -->
    <div id="earlyEndModal" class="modal"><div class="modal-content"><h3 class="text-xl font-bold mb-4">Session Ended Early</h3><p class="mb-4">How should this time be logged?</p><div class="flex flex-col space-y-3"><button id="earlyEndYesBtn" class="btn btn-green">Log as Completed Session</button><button id="earlyEndNoCountBtn" class="btn btn-blue">Log Time as Ad-hoc</button><button id="earlyEndNoDiscardBtn" class="btn btn-red">Discard Session</button></div></div></div>
    
    <!-- Manage Reason Modal -->
    <div id="manageReasonModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="this.parentElement.parentElement.style.display='none'">√ó</span>
            <h3 class="text-xl font-bold mb-4">Manage Reason</h3>
            <input type="hidden" id="originalReasonInput">
            
            <div class="mb-4">
                <label for="renameReasonInput" class="block text-sm font-medium text-gray-700">Rename Reason</label>
                <div class="flex mt-1">
                    <input type="text" id="renameReasonInput" class="flex-1 p-2 border rounded-l-md">
                    <button id="saveRenameBtn" class="btn btn-blue rounded-l-none">Save</button>
                </div>
            </div>

            <div class="mb-4">
                <label for="reassignReasonSelect" class="block text-sm font-medium text-gray-700">Re-assign all entries to</label>
                <div class="flex mt-1">
                    <select id="reassignReasonSelect" class="flex-1 p-2 border rounded-l-md"></select>
                    <button id="confirmReassignBtn" class="btn btn-orange rounded-l-none">Re-assign</button>
                </div>
            </div>

            <div class="mt-6 border-t pt-4">
                <button id="deleteReasonBtn" class="btn btn-red w-full">Delete This Reason Entirely</button>
            </div>
        </div>
    </div>
    
    <!-- Extended Break Modal -->
    <div id="extendedBreakModal" class="modal"><div class="modal-content"><h3 class="text-xl font-bold mb-4">Welcome Back!</h3><p id="extendedBreakMessage" class="mb-4"></p><div class="flex flex-col space-y-3"><button id="continueSessionBtn" class="btn btn-blue">Continue Session</button><button id="endCurrentSessionBtn" class="btn btn-orange">End Current Session</button></div></div></div>

    <!-- AI Insights Export Modal -->
    <div id="aiExportModal" class="modal">
        <div class="modal-content">
             <span class="close-button" onclick="this.parentElement.parentElement.style.display='none'">√ó</span>
            <h3 class="text-xl font-bold mb-4 text-purple-700">AI Insights Export</h3>
            <p class="text-sm text-gray-600 mb-4">To analyze your data with AI:</p>
            <ol class="list-decimal list-inside text-sm text-gray-600 mb-4 space-y-1">
                <li>Download your raw data file below.</li>
                <li>Copy the prompt instructions (or edit them to your liking).</li>
                <li>Upload the file and paste the instructions into your AI tool.</li>
            </ol>
            
            <div class="flex space-x-2 mb-4">
                <button id="downloadDataBtn" class="flex-1 btn btn-blue text-sm">Download Data (JSON)</button>
                <button id="downloadCodeBtn" class="flex-1 btn btn-gray text-sm">Download App Code</button>
            </div>

            <div class="mb-3">
                <div class="flex items-center">
                    <input type="checkbox" id="aiHabitTrackerCheckbox" class="h-4 w-4 text-blue-600 rounded border-gray-300">
                    <label for="aiHabitTrackerCheckbox" class="ml-2 text-sm text-gray-700 font-medium">I also use a Habit Tracker</label>
                </div>
            </div>

            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Prompt Instructions</label>
                <textarea id="aiPromptText" class="w-full p-2 border rounded-md bg-gray-50 text-xs text-gray-700 h-32" placeholder="AI instructions will appear here. You can edit and save them."></textarea>
                <p id="aiPromptSaveStatus" class="text-xs text-gray-500 h-4 mt-1 text-right"></p>
            </div>
            
            <div class="flex space-x-2">
                <button id="copyPromptBtn" class="flex-1 btn btn-green">Copy Prompt</button>
                <button id="resetPromptBtn" class="btn bg-gray-200 text-gray-600 text-xs px-3" title="Reset to default generated prompt">Reset</button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="this.parentElement.parentElement.style.display='none'">√ó</span>
            <h3 class="text-xl font-bold mb-4">Settings</h3>
            <div class="space-y-6">
                <!-- AI Insights Section -->
                <div class="p-4 bg-purple-50 rounded-lg border border-purple-100">
                    <h4 class="font-bold text-purple-800 mb-2">AI Insights</h4>
                    <p class="text-xs text-gray-600 mb-3">Export your data to get personalized analysis from AI tools.</p>
                    <button id="openAiExportBtn" class="btn btn-blue w-full text-sm">Export Data & Prompt</button>
                </div>
                 <div>
                    <label for="settingsSpotifyLink" class="block text-sm font-medium text-gray-700">Custom Spotify Link</label>
                    <input type="text" id="settingsSpotifyLink" class="mt-1 block w-full p-2 border rounded-md" placeholder="e.g., https://open.spotify.com/playlist/..."/>
                    <p class="text-xs text-gray-500 mt-1">You can paste any Spotify link (e.g., artist, playlist, or album). Regional codes and tracking info will be removed automatically.</p>
                    <p id="spotifySaveStatus" class="text-xs text-gray-500 h-4 mt-1"></p>
                </div>
                <div>
                    <label for="settingsMinSessionLength" class="block text-sm font-medium text-gray-700">Minimum Session Length (min)</label>
                    <input type="number" id="settingsMinSessionLength" class="mt-1 block w-full p-2 border rounded-md" placeholder="e.g., 15">
                     <p class="text-xs text-gray-500 mt-1">This helps ensure you give your brain enough time to enter a state of deep focus.</p>
                    <p id="minSessionSaveStatus" class="text-xs text-gray-500 h-4 mt-1"></p>
                </div>
                <div>
                    <label for="settingsWeekStartsOn" class="block text-sm font-medium text-gray-700">Week Starts On</label>
                    <select id="settingsWeekStartsOn" class="mt-1 block w-full p-2 border rounded-md">
                        <option value="0">Sunday</option>
                        <option value="1">Monday</option>
                    </select>
                    <p class="text-xs text-gray-500 mt-1">This affects the "Days Off" calendar and "Week" chart views.</p>
                </div>
                <div>
                    <label for="settingsRitualText" class="block text-sm font-medium text-gray-700">My Preparation Ritual</label>
                    <textarea id="settingsRitualText" rows="4" class="mt-1 block w-full p-2 border rounded-md" placeholder="e.g., Turn off notifications, put phone away..."></textarea>
                    <p id="ritualSaveStatus" class="text-xs text-gray-500 h-4 mt-1"></p>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700">My Break Activities</label>
                    <div class="flex mt-1">
                         <input type="text" id="newBreakActivityInput" class="flex-1 p-2 border rounded-l-md" placeholder="e.g., 5-minute walk"/>
                         <button id="addBreakActivityBtn" class="btn btn-green rounded-l-none">Add</button>
                    </div>
                    <p id="breakActivitySaveStatus" class="text-xs text-gray-500 h-4 mt-1"></p>
                    <ul id="breakActivitiesList" class="mt-2 space-y-2 max-h-40 overflow-y-auto"></ul>
                </div>
            </div>
        </div>
    </div>


    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { getFirestore, doc, collection, onSnapshot, setDoc, updateDoc, deleteDoc, getDoc, query, arrayUnion, arrayRemove, writeBatch } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
        
        // --- Firebase Configuration ---
        const yourOwnFirebaseConfig = {
            apiKey: "AIzaSyBr9SxXKQYKFWwARZtmv4jxPW5w579tUjY",
            authDomain: "focus-time-tracker-7757a.firebaseapp.com",
            projectId: "focus-time-tracker-7757a",
            storageBucket: "focus-time-tracker-7757a.firebasestorage.app",
            messagingSenderId: "795437053011",
            appId: "1:795437053011:web:fcab00d7a8d119762902a6"
        };
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : yourOwnFirebaseConfig;
        const APP_ID_FOR_FIRESTORE = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        // --- Firebase Services ---
        let app, auth, db;
        try {
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
        } catch (e) {
            console.error("Firebase initialization failed:", e);
            document.getElementById('loadingMessage').textContent = "Error: Could not connect to services.";
        }
        
        // --- Global State Variables ---
        let currentUser = null, userId = null, isAuthReady = false, unsubscribe = {}, chartInstance;
        let timerInterval, startTime, running = false, isSaving = false, accumulatedTime = 0, countdownDuration = 0;
        let sessionAbsoluteStartTime = null;
        let focusedTimeData = {}, goals = {}, daysOff = {}, lowQualityReasons = [];
        let notificationTimeoutId, notificationsEnabled, focusMusicEnabled;
        let calendarDate = new Date(), currentTimerMode = 'stopwatch', showAllLogEntries = false;
        let sessionDataForReflection = null;
        let sessionInterruptionTimestamps = [], sessionPauseEvents = [];

        let breakInterval = 0, breakTimerInterval, breakStartTime, lastContinueTime, breakNotificationShown = false;
        let overtimeInterval, overtimeStartTime, lastPauseStartTime = null;
        let userSettings = { ritual: '', breakActivities: [], spotifyLink: '', minSessionLength: null, weekStartsOn: 0 };
        let settingsSaveTimers = {};
        let displayedDate = null;
        let uiUpdateTimeout;
        let lastPenaltyResetTime = null;
        
        // Timeline View State
        let timelineViewDate = new Date();

        /**
         * Debounces UI updates to prevent rapid, unnecessary re-renders.
         */
        function debounceUpdateUI() {
            clearTimeout(uiUpdateTimeout);
            uiUpdateTimeout = setTimeout(updateAllUI, 50);
        }

        /**
         * Main initialization on DOM content loaded.
         */
        document.addEventListener('DOMContentLoaded', () => {
            // Load persistent toggle states from localStorage
            notificationsEnabled = localStorage.getItem('notificationToggleState') === 'true';
            document.getElementById('notificationToggle').checked = notificationsEnabled;
            focusMusicEnabled = localStorage.getItem('focusMusicToggleState') === 'true';
            document.getElementById('focusMusicToggle').checked = focusMusicEnabled;
            // Default manual entry date to today
            document.getElementById('newEntryDate').value = getLocalDateString(new Date());
            
            // Firebase Auth State Listener
            onAuthStateChanged(auth, user => {
                // Clear any existing data listeners
                Object.values(unsubscribe).forEach(unsub => unsub());
                unsubscribe = {};
                currentUser = user;
                if (user) {
                    userId = user.uid;
                    hideAuthModal();
                    attachDataListeners(); 
                } else {
                    userId = null;
                    clearUserData(); 
                    showAuthModal(); 
                }
                updateAuthUI();
                if (!isAuthReady) {
                    isAuthReady = true;
                    document.getElementById('loadingMessage').classList.add('hidden');
                }
            });
            setupEventListeners();
            // Periodically check goals and date
            setInterval(() => {
                checkAndManageGoalsUI();
                updateDashboardDate();
            }, 30 * 1000);
        });
        
        function attachDataListeners() {
            if (!userId) return;
            let dataLoaded = { focusSessions: false, goals: false, daysOff: false, reasons: false, settings: false };
            const checkAllDataLoaded = () => { if (Object.values(dataLoaded).every(v => v)) updateAllUI(); };
            
            const createSnapshotHandler = (collectionName, dataProcessor) => {
                return (snapshot) => {
                    dataProcessor(snapshot);
                    if (!dataLoaded[collectionName]) {
                        dataLoaded[collectionName] = true;
                        checkAllDataLoaded();
                    } else if (isAuthReady) {
                        debounceUpdateUI();
                    }
                };
            };

            const collections = {
                focusSessions: createSnapshotHandler('focusSessions', snapshot => {
                    snapshot.docChanges().forEach((change) => {
                        const docId = change.doc.id;
                        if (change.type === "removed") {
                            delete focusedTimeData[docId];
                        } else { 
                            focusedTimeData[docId] = change.doc.data();
                        }
                    });
                }),
                goals: createSnapshotHandler('goals', s => { goals = {}; s.forEach(d => { goals[d.id] = d.data() }); }),
                daysOff: createSnapshotHandler('daysOff', s => { daysOff = {}; s.forEach(d => { daysOff[d.id] = d.data() }); }),
            };

            Object.entries(collections).forEach(([col, handler]) => {
                const q = query(collection(db, `artifacts/${APP_ID_FOR_FIRESTORE}/users/${userId}/${col}`));
                unsubscribe[col] = onSnapshot(q, handler, err => console.error(`Error on ${col}:`, err));
            });

            const reasonsDocRef = doc(db, `artifacts/${APP_ID_FOR_FIRESTORE}/users/${userId}/reflectionData/reasons`);
            unsubscribe.reasons = onSnapshot(reasonsDocRef, createSnapshotHandler('reasons', docSnap => {
                lowQualityReasons = docSnap.exists() ? docSnap.data().reasons : [];
            }));

            const settingsDocRef = doc(db, `artifacts/${APP_ID_FOR_FIRESTORE}/users/${userId}/settings/main`);
            
            // UPDATE: Add 'customAiPrompt: null' to the defaults
            const defaultSettings = { ritual: '', breakActivities: [], spotifyLink: '', minSessionLength: null, weekStartsOn: 0, customAiPrompt: null };
            
            unsubscribe.settings = onSnapshot(settingsDocRef, createSnapshotHandler('settings', docSnap => {
                userSettings = docSnap.exists() ? { ...defaultSettings, ...docSnap.data() } : defaultSettings;
                userSettings.weekStartsOn = parseInt(userSettings.weekStartsOn) || 0;
            }));
        }

        function clearUserData() {
            focusedTimeData = {};
            goals = {}; daysOff = {}; 
            userSettings = { ritual: '', breakActivities: [], spotifyLink: '', minSessionLength: null, weekStartsOn: 0 };
            if(chartInstance) chartInstance.destroy();
            updateAllUI();
        }
        
        function showAuthModal() {
            const closeBtn = document.getElementById('closeAuthModalBtn'), anonBtn = document.getElementById('anonymousSignInBtn');
            if (currentUser && currentUser.isAnonymous) { closeBtn.style.display = 'block'; anonBtn.style.display = 'none'; }
            else { closeBtn.style.display = 'none'; anonBtn.style.display = 'block'; }
            document.getElementById('authModal').style.display = 'flex';
            document.getElementById('appSection').classList.add('hidden');
        }

        function hideAuthModal() {
            document.getElementById('authModal').style.display = 'none';
            document.getElementById('authErrorMessage').textContent = '';
            document.getElementById('appSection').classList.remove('hidden');
        }

        function updateAuthUI() {
            const authContainer = document.getElementById('authContainer');
            authContainer.innerHTML = ''; 
            if (currentUser) {
                const userInfoEl = document.createElement('span');
                userInfoEl.className = 'text-gray-600 text-sm hidden sm:block'; authContainer.appendChild(userInfoEl);
                // Settings Button
                const settingsBtn = document.createElement('button'); settingsBtn.id = 'settingsBtn';
                settingsBtn.className = 'p-2 bg-gray-200 hover:bg-gray-300 rounded-full transition-all'; settingsBtn.title = 'Settings';
                settingsBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-settings text-gray-600"><path d="M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58a.5.5 0 0 0 .1-2.45l-1.5-2.6a.5.5 0 0 0-.57-.26l-2.48.98c-.42-.31-.88-.58-1.38-.79l-.38-2.65A.5.5 0 0 0 14.25 2h-4.5a.5.5 0 0 0-.5.42l-.38 2.65c-.5.21-.96.48-1.38.79l-2.48-.98a.5.5 0 0 0-.57.26l-1.5 2.6a.5.5 0 0 0 .1 2.45l2.03 1.58c-.05.3-.07.62-.07.94s.02.64.07.94l-2.03 1.58a.5.5 0 0 0-.1 2.45l1.5 2.6a.5.5 0 0 0 .57.26l2.48-.98c.42.31.88.58 1.38.79l.38 2.65a.5.5 0 0 0 .5.42h4.5a.5.5 0 0 0 .5.42l.38-2.65c-.5-.21.96-.48 1.38-.79l2.48.98a.5.5 0 0 0 .57-.26l1.5-2.6a.5.5 0 0 0-.1-2.45l-2.03-1.58z"></path><circle cx="12" cy="12" r="3"></circle></svg>`;
                settingsBtn.addEventListener('click', openSettingsModal); authContainer.appendChild(settingsBtn);
                
                if (currentUser.isAnonymous) {
                    userInfoEl.textContent = 'Anonymous User';
                    const registerBtn = document.createElement('button'); registerBtn.className = 'btn btn-green text-sm py-2 px-4'; registerBtn.textContent = 'Sign In / Register'; registerBtn.addEventListener('click', showAuthModal); authContainer.appendChild(registerBtn);
                } else {
                    userInfoEl.textContent = currentUser.email;
                    const signOutBtn = document.createElement('button'); signOutBtn.className = 'p-2 bg-gray-200 hover:bg-gray-300 rounded-full transition-all'; signOutBtn.title = 'Sign Out';
                    signOutBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-gray-600"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"/><polyline points="17 16 22 12 17 8"/><line x1="22" y1="12" x2="10" y2="12"/></svg>`;
                    signOutBtn.addEventListener('click', () => signOut(auth)); authContainer.appendChild(signOutBtn);
                }
            } else {
                const signInBtn = document.createElement('button');
                signInBtn.className = 'btn btn-blue'; signInBtn.textContent = 'Sign In / Register'; signInBtn.addEventListener('click', showAuthModal); authContainer.appendChild(signInBtn);
            }
        }

        function updateAllUI() {
            if (!isAuthReady || !currentUser) return;
            updateDashboardDate();
            checkAndManageGoalsUI(); updateDashboard(); renderCalendar(); renderLog();
            
            // Render Daily Timeline
            renderDailyTimeline();

            const chartType = document.getElementById('chartTypeSelect').value;
            if (chartType === 'interruptionLikelihood') {
                setupComparisonControls();
            } else if (chartType === 'reasonBubbleChart') {
                setupReasonChartControls(); 
            } else {
                renderChart(); 
            }
        }

        function updateDashboardDate() {
            const today = new Date();
            const day = String(today.getDate()).padStart(2, '0');
            const month = String(today.getMonth() + 1).padStart(2, '0');
            const year = today.getFullYear();
            const todayStr = `${day}.${month}.${year}`; // Format: DD.MM.YYYY
            
            // Check if the date has changed (e.g., midnight passed or computer woke up)
            if (displayedDate !== todayStr) {
                // 1. Capture the date currently shown on the timeline before we update anything
                const currentTimelineStr = getLocalDateString(timelineViewDate);
                
                // 2. Determine what the "Old Today" was (from the displayedDate variable)
                // displayedDate is in DD.MM.YYYY, we need YYYY-MM-DD for comparison
                let oldTodayIso = null;
                if (displayedDate) {
                    const parts = displayedDate.split('.');
                    if (parts.length === 3) oldTodayIso = `${parts[2]}-${parts[1]}-${parts[0]}`;
                }

                // 3. Update the Dashboard Text
                document.getElementById('kpiDashboardTitle').textContent = `KPI Dashboard ${todayStr}`;
                
                // 4. THE FIX: If the timeline was looking at the "Old Today", jump it to the "New Today"
                // We check if (timeline matches old date) OR (timeline matches today but text says "Today")
                const isViewingOldToday = oldTodayIso && currentTimelineStr === oldTodayIso;
                const isViewingTodayUI = document.getElementById('tlDateDisplay').textContent === "Today";

                if (isViewingOldToday || isViewingTodayUI) {
                     timelineViewDate = new Date(); // Update variable to new real time
                     renderDailyTimeline();         // Re-render the timeline
                }
                
                // 5. Update state variables
                displayedDate = todayStr;
                updateDashboard();
                
                // 6. Auto-update manual entry date input
                const todayIsoStr = getLocalDateString(today);
                const manualDateInput = document.getElementById('newEntryDate');
                if (manualDateInput.value !== todayIsoStr) {
                     manualDateInput.value = todayIsoStr;
                }
            }
        }
        
        function formatTimer(s) {
            s = Math.max(0, s);
            const h = String(Math.floor(s / 3600)).padStart(2, '0'), m = String(Math.floor((s % 3600) / 60)).padStart(2, '0'), sec = String(Math.floor(s % 60)).padStart(2, '0');
            return `${h}:${m}:${sec}`;
        }
        
        function getLocalDateString(d) {
            if (!d || !(d instanceof Date)) {
                return null;
            }
            const year = d.getFullYear();
            const month = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function updateTimerDisplay() {
            const elapsedSeconds = accumulatedTime / 1000 + (running ? (Date.now() - startTime) / 1000 : 0);
            const displaySeconds = (currentTimerMode === 'stopwatch') ? elapsedSeconds : Math.max(0, countdownDuration - elapsedSeconds);
            document.getElementById('timeValue').textContent = formatTimer(displaySeconds);
            document.getElementById('sessionInterruptionsDisplay').textContent = sessionInterruptionTimestamps.length;
            
            const nextBreakEl = document.getElementById('nextBreakCountdown');
            if (running && currentTimerMode === 'countdown' && breakInterval > 0 && lastContinueTime) {
                const elapsedSinceContinue = (Date.now() - lastContinueTime) / 1000;
                const secondsToNextBreak = breakInterval - elapsedSinceContinue;
                
                if (secondsToNextBreak <= 0) {
                    nextBreakEl.textContent = "Time for a break! ‚òïÔ∏è";
                    nextBreakEl.classList.remove('hidden');
                    if (!breakNotificationShown) {
                        if (Notification.permission === 'granted') {
                            new Notification('Time for a break!', { body: 'Step away for a few minutes to refresh.', icon: "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>‚òïÔ∏è</text></svg>" });
                        }
                        breakNotificationShown = true;
                    }
                } else if (displaySeconds > secondsToNextBreak) {
                    nextBreakEl.textContent = `Next Pause In: ${Math.ceil(secondsToNextBreak / 60)} min`;
                    nextBreakEl.classList.remove('hidden');
                } else {
                    nextBreakEl.classList.add('hidden');
                }
            } else {
                 nextBreakEl.classList.add('hidden');
            }
            if (currentTimerMode === 'countdown' && displaySeconds <= 0 && running) { completeCountdown();
            }
        }

        function completeCountdown() {
            if (isSaving) return;
            running = false; 
            clearInterval(timerInterval);
            
            new Audio("https://actions.google.com/sounds/v1/impacts/gong_strike.ogg").play().catch(e => console.warn("Audio fail:", e));
            if (Notification.permission === 'granted') { new Notification('Focus session complete!', { body: 'Great work! Time to reflect.', icon: "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üèÖ</text></svg>"});
            }
            
            accumulatedTime = countdownDuration * 1000;
            handleEndFocus(true); 
        }
        
        function toggleTimer() {
            if (running) { 
                document.getElementById('interruptionPromptModal').style.display = 'flex';
                return;
            }

            if(lastPauseStartTime) {
                const breakDuration = Date.now() - lastPauseStartTime;
                const accumulatedMinutes = accumulatedTime / 1000 / 60;
                let thresholdMinutes;
                if (accumulatedMinutes < 45) { thresholdMinutes = 10; } 
                else if (accumulatedMinutes < 60) { thresholdMinutes = 15; } 
                else if (accumulatedMinutes < 75) { thresholdMinutes = 20; } 
                else { thresholdMinutes = 30; }

                if (breakDuration > thresholdMinutes * 60 * 1000) {
                    document.getElementById('extendedBreakMessage').textContent = `You've been on a break for ${Math.round(breakDuration / (60 * 1000))} minutes. Would you like to continue this session or end it?`;
                    document.getElementById('extendedBreakModal').style.display = 'flex';
                    lastPauseStartTime = null; 
                    return;
                }
                lastPauseStartTime = null;
            }
            
            if (currentTimerMode === 'countdown' && countdownDuration === 0) {
                const countdownMinutesInput = document.getElementById('countdownMinutes');
                const minLength = userSettings.minSessionLength;
                if (minLength && minLength > 0) {
                    countdownMinutesInput.value = minLength;
                } else {
                    countdownMinutesInput.value = 25; 
                }
                
                const startCountdownBtn = document.getElementById('startCountdownBtn');
                const countdownErrorEl = document.getElementById('countdownError');
                if (minLength && minLength > 0 && parseInt(countdownMinutesInput.value) < minLength) {
                    countdownErrorEl.textContent = `It takes time to build focus. Try a session of at least ${minLength} minutes.`;
                    startCountdownBtn.disabled = true;
                } else {
                    countdownErrorEl.textContent = '';
                    startCountdownBtn.disabled = false;
                }
                
                document.getElementById('ritualText').textContent = userSettings.ritual || 'No ritual set. Go to Settings to add one.';
                document.getElementById('countdownModal').style.display = 'flex';
            } else { 
                startTimer();
            }
        }
        
        function startTimer() {
            if (running) return;
            if (accumulatedTime === 0) {
                sessionAbsoluteStartTime = Date.now();
                lastPenaltyResetTime = sessionAbsoluteStartTime;
            } else {
                lastPenaltyResetTime = Date.now();
            }

            if (sessionPauseEvents.length > 0 && !sessionPauseEvents[sessionPauseEvents.length - 1].end) {
                const currentTotalElapsed = (sessionAbsoluteStartTime ? Date.now() - sessionAbsoluteStartTime : 0) / 1000;
                sessionPauseEvents[sessionPauseEvents.length - 1].end = currentTotalElapsed;
            }
            stopBreakTimer();
            running = true; startTime = Date.now();
            breakNotificationShown = false; 
            
            const remainingTime = countdownDuration - (accumulatedTime / 1000);
            if (currentTimerMode === 'countdown' && breakInterval > 0 && remainingTime > breakInterval) {
                 lastContinueTime = Date.now();
            } else {
                lastContinueTime = null;
            }
            
            timerInterval = setInterval(updateTimerDisplay, 500);
            document.getElementById('togglePauseBtn').textContent = 'Pause'; document.getElementById('togglePauseBtn').classList.replace('btn-green', 'btn-orange'); document.getElementById('logInterruptionBtn').disabled = false;
            if (notificationsEnabled) scheduleNextNotification();
            if (focusMusicEnabled) {
                launchSpotify();
            }
        }
        
        function pauseTimer() {
            if (!running) return;
            document.getElementById('nextBreakCountdown').classList.add('hidden');
            running = false; clearInterval(timerInterval); accumulatedTime += Date.now() - startTime;
            lastPauseStartTime = Date.now();
            
            const currentTotalElapsed = (sessionAbsoluteStartTime ? (Date.now() - sessionAbsoluteStartTime) : accumulatedTime) / 1000;
            sessionPauseEvents.push({ start: currentTotalElapsed, end: null });

            document.getElementById('togglePauseBtn').textContent = 'Continue'; document.getElementById('togglePauseBtn').classList.replace('btn-orange', 'btn-green'); document.getElementById('logInterruptionBtn').disabled = true; clearTimeout(notificationTimeoutId);
            startBreakTimer();
        }
        
        function showReflectionModal(details) {
            sessionDataForReflection = details;
            const modal = document.getElementById('reflectionModal');
            modal.style.display = 'flex'; 

            const timelineContainer = document.getElementById('reflectionTimelineContainer');
            const timeline = document.getElementById('reflectionTimeline');
            
            timeline.innerHTML = '';
            timelineContainer.querySelectorAll('.timeline-marker').forEach(m => m.remove());

            const totalSessionTime = details.totalSessionDuration / 1000;
            if (totalSessionTime <= 0) return;

            const totalSessionMinutes = totalSessionTime / 60;
            const normalizedInterruptions = (details.interruptions || []).map(i =>
                (typeof i === 'number') ? { time: i, penalty: 0 } : i
            );

            const eventPoints = new Set([0, totalSessionTime]);
            details.pauseEvents?.forEach(p => {
                eventPoints.add(p.start);
                eventPoints.add(p.end);
            });
            normalizedInterruptions.forEach(i => {
                eventPoints.add(i.time);
                eventPoints.add(i.time - i.penalty);
            });
            const sortedPoints = Array.from(eventPoints).filter(p => p >= 0 && p <= totalSessionTime).sort((a, b) => a - b);
            
            for (let i = 0; i < sortedPoints.length - 1; i++) {
                const start = sortedPoints[i];
                const end = sortedPoints[i+1];
                const midPoint = start + (end - start) / 2;

                let segmentType = 'focus'; 
                
                if (details.pauseEvents?.some(p => midPoint >= p.start && midPoint < p.end)) {
                    segmentType = 'break';
                }
                
                let isPenalty = normalizedInterruptions.some(p => midPoint >= (p.time - p.penalty) && midPoint < p.time);

                const segment = document.createElement('div');
                segment.className = 'timeline-segment';
                const startPercent = (start / totalSessionTime) * 100;
                const widthPercent = ((end - start) / totalSessionTime) * 100;
                segment.style.left = `${startPercent}%`;
                segment.style.width = `${widthPercent}%`;
                
                if (segmentType === 'break') {
                    segment.classList.add('timeline-break');
                    segment.title = `Break: ${Math.round((end - start)/60)} min`;
                } else {
                    const focusSegment = document.createElement('div');
                    focusSegment.className = 'timeline-segment timeline-focus';
                    focusSegment.style.left = `${startPercent}%`;
                    focusSegment.style.width = `${widthPercent}%`;
                    timeline.appendChild(focusSegment);

                    if (isPenalty) {
                        segment.classList.add('timeline-penalty');
                        segment.title = `Penalty`;
                    } else {
                        continue; 
                    }
                }
                 timeline.appendChild(segment);
            }
            
            normalizedInterruptions.forEach(interruption => {
                const dot = document.createElement('div');
                dot.className = 'timeline-dot';
                dot.style.left = `${(interruption.time / totalSessionTime) * 100}%`;
                dot.title = `Interruption at ~${Math.round(interruption.time/60)} min`;
                timeline.appendChild(dot);
            });
            
            const timelineWidth = timeline.offsetWidth;
            if (timelineWidth > 0) {
                const minMarkerPixelSpacing = 40;
                let interval = 1; 
                if (totalSessionMinutes > 5) interval = 5;
                if (totalSessionMinutes > 25) interval = 10;
                if (totalSessionMinutes > 50) interval = 15;
                
                while ((interval / totalSessionMinutes) * timelineWidth < minMarkerPixelSpacing && interval < totalSessionMinutes / 2) {
                   if (interval < 5) interval = 5;
                   else if(interval < 10) interval = 10; else interval += 10;
                }
                for (let min = interval; min < totalSessionMinutes; min += interval) {
                    const marker = document.createElement('div');
                    marker.className = 'timeline-marker';
                    marker.textContent = `${min}m`;
                    marker.style.left = `${(min / totalSessionMinutes) * 100}%`;
                    timelineContainer.appendChild(marker);
                }
            }

            const stars = modal.querySelectorAll('.star-rating .fa-star');
            const suggestion = getHistoricalRatingSuggestion(details.duration, normalizedInterruptions);
            let suggestionText = `With ${normalizedInterruptions.length} interruptions and this focus duration, we suggest a quality rating of ${suggestion} stars.`;
            document.getElementById('reflectionSuggestionText').textContent = suggestionText;
            stars.forEach(s => s.classList.remove('selected'));
            for (let i = 0; i < suggestion; i++) { stars[i].classList.add('selected');
            }
            modal.querySelector('.star-rating').dataset.rating = suggestion;
            setupStarRating(modal.querySelector('.star-rating'));
        }

        async function stopAndSaveSession(details) {
			const { duration, interruptions = [], pauseEvents = [], quality = null, reason = null, type, startTime } = details;
			
			// ... existing check for isSaving ...

			isSaving = true;
			// Use the passed startTime for the date bucket, or fallback to today
			const sessionDateObj = startTime ? new Date(startTime) : new Date();
			const today = getLocalDateString(sessionDateObj);

			const newSession = { 
				id: crypto.randomUUID(), 
				duration: Math.floor(duration / 1000), 
				interruptions, 
				pauseEvents,
				quality, 
				reason, 
				// 2. Use the captured Start Time as the timestamp
				timestamp: startTime || new Date().toISOString(), 
				// 3. Add this flag so the timeline knows this is a "Start Time" entry
				isStartTime: true,
				type 
			};

            if (!focusedTimeData[today]) {
                focusedTimeData[today] = { sessions: [] };
            }
            if (!focusedTimeData[today].sessions.find(s => s.id === newSession.id)) {
                focusedTimeData[today].sessions.push(newSession);
            }
            debounceUpdateUI();

            try {
                const docRef = doc(db, `artifacts/${APP_ID_FOR_FIRESTORE}/users/${userId}/focusSessions`, today);
                const docSnap = await getDoc(docRef);
                const existing = docSnap.exists() && docSnap.data().sessions ? docSnap.data().sessions.filter(s => s.id !== newSession.id) : [];
                await setDoc(docRef, { sessions: [...existing, newSession] }, { merge: true });
                if (reason && !lowQualityReasons.includes(reason)) {
                    const reasonsRef = doc(db, `artifacts/${APP_ID_FOR_FIRESTORE}/users/${userId}/reflectionData/reasons`);
                    await setDoc(reasonsRef, { reasons: arrayUnion(reason) }, { merge: true });
                }
            } catch (e) { showMessage("Could not save session: " + e.message);
            }
            resetTimerState(); isSaving = false;
        }

        function resetTimerState() {
            running = false;
            clearInterval(timerInterval); stopBreakTimer(); clearInterval(overtimeInterval);
            clearTimeout(notificationTimeoutId);
            overtimeInterval = null; overtimeStartTime = null; accumulatedTime = 0; 
            sessionInterruptionTimestamps = []; sessionPauseEvents = [];
            sessionAbsoluteStartTime = null;
            countdownDuration = 0; breakInterval = 0; isSaving = false; sessionDataForReflection = null;
            lastContinueTime = null;
            lastPenaltyResetTime = null;
            lastPauseStartTime = null;
            updateTimerDisplay();
            document.getElementById('togglePauseBtn').textContent = 'Start Focusing'; document.getElementById('togglePauseBtn').classList.replace('btn-orange', 'btn-green'); document.getElementById('logInterruptionBtn').disabled = true;
        }
        
        function checkAllGoalsMet(dateStr) {
            const dayGoals = goals[dateStr];
            if (!dayGoals) return false; 

            const { dailyGoal = 0, scheduledSessionsGoal = 0, interruptionGoal = 0 } = dayGoals;
            if (dailyGoal === 0 && scheduledSessionsGoal === 0 && interruptionGoal === 0) return false; 
            
            const daySessions = focusedTimeData[dateStr]?.sessions || [];

            const totalSeconds = daySessions.reduce((sum, s) => sum + s.duration, 0);
            const totalMinutes = totalSeconds / 60;
            if (dailyGoal > 0 && totalMinutes < dailyGoal) {
                return false;
            }

            const completedSessions = daySessions.filter(s => s.type === 'countdown').length;
            if (scheduledSessionsGoal > 0 && completedSessions < scheduledSessionsGoal) {
                return false;
            }

            const relevantSessions = daySessions.filter(s => !s.isManual || (s.isManual && s.interruptions != null));
            const totalDurationForMpi = relevantSessions.reduce((sum, s) => sum + s.duration, 0);
            const totalInterruptions = relevantSessions.reduce((sum, s) => sum + (s.interruptions?.length || 0), 0);
            const minsPerInterruption = totalDurationForMpi > 0 ? (totalDurationForMpi / 60) / (totalInterruptions + 1) : 0;
            
            if (interruptionGoal > 0 && minsPerInterruption < interruptionGoal) {
                return false;
            }
            return true; 
        }

        function updateDashboard() {
            const todayStr = getLocalDateString(new Date());
            const todaysGoalData = goals[todayStr];
            const todaySessions = focusedTimeData[todayStr]?.sessions || [];
            
            const totalSecondsToday = todaySessions.reduce((sum, s) => sum + s.duration, 0);
            const totalMinutesToday = Math.floor(totalSecondsToday / 60);
            const dailyGoal = todaysGoalData?.dailyGoal ?? 0;
            document.getElementById('todayProgressBar').style.width = `${dailyGoal > 0 ? Math.min(100, (totalMinutesToday / dailyGoal) * 100) : 0}%`;
            document.getElementById('todayProgressText').textContent = `${totalMinutesToday} / ${dailyGoal} min`;
            
            const scheduledSessions = todaysGoalData?.scheduledSessionsGoal ?? 0;
            const completedSessions = todaySessions.filter(s => s.type === 'countdown').length;
            document.getElementById('sessionsProgressBar').style.width = `${scheduledSessions > 0 ? Math.min(100, (completedSessions / scheduledSessions) * 100) : 0}%`;
            document.getElementById('sessionsProgressText').textContent = `${completedSessions} / ${scheduledSessions}`;
            
            let streak = 0;
            let d = new Date();
            if (!checkAllGoalsMet(getLocalDateString(new Date()))) {
                d.setDate(d.getDate() - 1); 
            }
            while (true) {
                const dateStr = getLocalDateString(d);
                if (isDayOff(dateStr)) {
                    d.setDate(d.getDate() - 1);
                    continue; 
                }
                if (checkAllGoalsMet(dateStr)) {
                    streak++;
                    d.setDate(d.getDate() - 1);
                } else {
                    break; 
                }
            }
            document.getElementById('streakText').textContent = `${streak} Days`;

            const relevantSessionsForMpi = todaySessions.filter(s => !s.isManual || (s.isManual && s.interruptions != null));
            const totalDurationForMpi = relevantSessionsForMpi.reduce((sum, s) => sum + s.duration, 0);
            const totalInterruptionsForMpi = relevantSessionsForMpi.reduce((sum, s) => sum + (s.interruptions?.length || 0), 0);
            const minsPerInterruptionToday = totalDurationForMpi > 0 ? Math.floor((totalDurationForMpi / 60) / (totalInterruptionsForMpi + 1)) : 0;

            const goalMinsPerInterruption = todaysGoalData?.interruptionGoal ?? 0;
            const container = document.getElementById('minsPerInterruptionContainer');
            let comparisonHTML = '';
            if (goalMinsPerInterruption > 0) {
                const symbol = minsPerInterruptionToday >= goalMinsPerInterruption ? '‚â•' : '<';
                comparisonHTML = `<span class="text-gray-500 text-2xl font-bold mx-2">${symbol}</span> <p class="text-2xl font-bold text-red-500">${goalMinsPerInterruption} min</p>`;
            }
            container.innerHTML = `<p id="minsPerInterruptionText" class="text-2xl font-bold text-red-500">${minsPerInterruptionToday} min</p>${comparisonHTML}`;
            
            const maxFocus = calculateMaxUninterruptedFocus(todayStr, true);
            document.getElementById('maxFocusText').textContent = `${Math.floor(maxFocus / 60)} min`;
        }
        
        function calculateMaxUninterruptedFocus(dateStr, excludeManual = false) {
            const sessions = (focusedTimeData[dateStr]?.sessions || []).filter(s => !s.isManual);
            let maxFocus = 0;
            sessions.forEach(s => {
                const interruptions = (s.interruptions || []).map(i => (typeof i === 'number') ? { time: i, penalty: 0 } : i);
                if (interruptions.length === 0) {
                    if (s.duration > maxFocus) maxFocus = s.duration;
                } else {
                    let lastTimestamp = 0;
                    interruptions.sort((a,b) => a.time - b.time).forEach(interruption => {
                        const segmentDuration = (interruption.time - interruption.penalty) - lastTimestamp;
                        if (segmentDuration > maxFocus) maxFocus = segmentDuration;
                        lastTimestamp = interruption.time;
                    });
                    if ((s.duration - lastTimestamp) > maxFocus) maxFocus = s.duration - lastTimestamp;
                }
            });
            return maxFocus;
        }

        function isDayOff(dateStr) {
            const d = new Date(dateStr + 'T12:00:00Z');
            const day = d.getUTCDay(); 
            const isWknd = day === 0 || day === 6; 
            const dayOff = daysOff[dateStr];
            return dayOff ? !dayOff.isWorkDay : isWknd; 
        }

        function renderCalendar() {
            const grid = document.getElementById('calendarGrid');
            grid.innerHTML = ''; 
            calendarDate.setDate(1); 
            const month = calendarDate.getMonth(), year = calendarDate.getFullYear();
            document.getElementById('calendarMonthYear').textContent = `${calendarDate.toLocaleString('default', { month: 'long' })} ${year}`;
            
            const weekStartsOn = userSettings.weekStartsOn || 0; 
            
            const headers = (weekStartsOn === 1) 
                ? ['M', 'T', 'W', 'T', 'F', 'S', 'S'] 
                : ['S', 'M', 'T', 'W', 'T', 'F', 'S'];
            headers.forEach(d => { grid.innerHTML += `<div class="font-bold text-gray-500 text-sm">${d}</div>` });
            
            const firstDayStr = getLocalDateString(calendarDate); 
            const firstDayAtUtcNoon = new Date(firstDayStr + 'T12:00:00Z');
            const firstDayRaw = firstDayAtUtcNoon.getUTCDay(); 
                
            const firstDayOffset = (weekStartsOn === 1) 
                ? (firstDayRaw === 0 ? 6 : firstDayRaw - 1) 
                : firstDayRaw; 
                
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            
            for (let i = 0; i < firstDayOffset; i++) { grid.appendChild(document.createElement('div'));
            }
            
            const today = new Date();
            const todayDate = today.getDate(), todayMonth = today.getMonth(), todayYear = today.getFullYear();
            for (let i = 1; i <= daysInMonth; i++) {
                const dayEl = document.createElement('div');
                dayEl.textContent = i;
                const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(i).padStart(2, '0')}`;
                dayEl.className = 'calendar-day cursor-pointer p-2 rounded-full text-sm';
                if (isDayOff(dateStr)) { dayEl.classList.add('day-off-explicit'); }
                if (i === todayDate && month === todayMonth && year === todayYear) { 
                    dayEl.classList.add('today'); 
                }
                dayEl.addEventListener('click', () => toggleDayOff(dateStr));
                grid.appendChild(dayEl);
            }
        }

        async function toggleDayOff(d) {
            if (!userId) return;
            const docRef = doc(db, `artifacts/${APP_ID_FOR_FIRESTORE}/users/${userId}/daysOff`, d);
            const day = new Date(d + 'T12:00:00Z').getUTCDay();
            if (daysOff[d]) { await deleteDoc(docRef); 
            } else { await setDoc(docRef, { isWorkDay: day === 0 || day === 6 }); 
            }
        }

        function renderChart() {
            if (chartInstance) { chartInstance.destroy();
            }
            const chartType = document.getElementById('chartTypeSelect').value;
            
            let viewType;
            if (chartType !== 'reasonBubbleChart') {
                const activeViewBtn = document.querySelector('#chartViewControls .view-btn.active') || document.getElementById('viewDay');
                if (activeViewBtn) { 
                    viewType = activeViewBtn.id.replace('view', '').toLowerCase();
                }
            }
            
            const infoContainer = document.getElementById('chartInfoIconContainer');
            infoContainer.innerHTML = '';
            if(chartType === 'minsPerInterruption') {
                infoContainer.innerHTML = `<div class="info-tooltip-container">
                    <i class="fa-solid fa-info-circle text-gray-400 cursor-pointer"></i>
                    <span class="info-tooltip-text">"Max" displays the longest uninterrupted focus time from timer sessions in the period.</span>
                </div>`;
            } else if (chartType === 'interruptionLikelihood') {
                 infoContainer.innerHTML = `<div class="info-tooltip-container">
                    <i class="fa-solid fa-info-circle text-gray-400 cursor-pointer"></i>
                    <span class="info-tooltip-text">This chart shows the average number of interruptions you experience for every 15 minutes of focus within each time interval. A higher value means you're more likely to be interrupted during that period.</span>
                 </div>`;
            }
            
            const maxLinePlugin = {
                id: 'maxLinePlugin',
                afterDraw: (chart) => {
                    const maxDatasetIndex = chart.data.datasets.findIndex(ds => ds.label === 'Max');
                    if (maxDatasetIndex === -1) return;

                    const ctx = chart.ctx;
                    const maxMeta = chart.getDatasetMeta(maxDatasetIndex);
                    const barMeta = chart.getDatasetMeta(0); 
                    if (!barMeta) return;
                    maxMeta.data.forEach((point, index) => {
                        const bar = barMeta.data[index];
                        if (bar) {
                            ctx.save();
                            ctx.beginPath();
                            ctx.moveTo(bar.x - bar.width / 2, point.y);
                            ctx.lineTo(bar.x + bar.width / 2, point.y);
                            ctx.lineWidth = 3;
                            ctx.strokeStyle = 'black';
                            ctx.stroke();
                            ctx.restore();
                        }
                    });
                }
            };

            const chartData = getChartData(viewType, chartType); 
            const canvas = document.getElementById('timeChart');
            const ctx = canvas.getContext('2d');
            
            if (!chartData || (chartData.labels && chartData.labels.length === 0)) {
                chartInstance = new Chart(ctx, { type: 'bar', data: { labels: [], datasets: [] }, options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true } }, plugins: { legend: { display: false }, title: { display: true, text: 'No data available for this period.' }}}});
                return;
            }
            
            if (chartType === 'reasonBubbleChart') {
                 chartInstance = new Chart(ctx, { type: 'bubble', data: { datasets: [{ label: 'Reasons for Low Quality', data: chartData.data, backgroundColor: 'rgba(239, 68, 68, 0.7)' }] }, options: { responsive: true, maintainAspectRatio: false, scales: { x: { display: false }, y: { display: false } }, plugins: { legend: { display: false }, tooltip: { callbacks: { label: c => `${chartData.labels[c.dataIndex]}: ${c.raw.rawCount} times` }}}, onClick: (evt) => { 
                 const points = chartInstance.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, true); if (points.length) { const firstPoint = points[0]; const label = chartData.labels[firstPoint.index]; openManageReasonModal(label);}}}});
            } else {
                const { labels, datasets, unitSuffix, type, stacked, tooltipData } = chartData;
                
                let yAxisOptions = {
                    type: 'linear',
                    stacked, 
                    beginAtZero: true,
                    ticks: {} 
                };

                if (['avgDailyFocusTime', 'totalFocusTime', 'minsPerInterruption'].includes(chartType)) {
                    const allData = datasets.flatMap(ds => ds.data).filter(val => val !== null && !isNaN(val));
                    const dataMax = allData.length > 0 ? Math.max(...allData) : 0;
                    const maxHours = dataMax / 3600;

                    let stepSizeInSeconds;

                    if (maxHours <= 0.75) { stepSizeInSeconds = 900; } 
                    else if (maxHours <= 2.5) { stepSizeInSeconds = 1800; } 
                    else if (maxHours <= 6) { stepSizeInSeconds = 3600; } 
                    else if (maxHours <= 12) { stepSizeInSeconds = 7200; } 
                    else if (maxHours <= 30) { stepSizeInSeconds = 18000; } 
                    else { stepSizeInSeconds = 36000; }

                    yAxisOptions.ticks.stepSize = stepSizeInSeconds;

                    if (dataMax > 0 && stepSizeInSeconds > 0) {
                        yAxisOptions.max = Math.ceil(dataMax / stepSizeInSeconds) * stepSizeInSeconds;
                    }

                    yAxisOptions.ticks.callback = function(value) {
                        if (value === 0) return '0';
                        const totalMinutes = value / 60;
                        const totalHours = value / 3600;
                        const scaleMaxHours = this.max / 3600;
                        if (scaleMaxHours < 1) { 
                            return `${Math.round(totalMinutes)}m`;
                        } else {
                            return `${parseFloat(totalHours.toFixed(1))}h`;
                        }
                    };

                } else if (chartType === 'interruptionLikelihood') {
                    yAxisOptions.ticks.callback = function(value) {
                        return value.toFixed(1);
                    };
                } else {
                    yAxisOptions.ticks.callback = function(value) {
                        return `${value.toFixed(1)}${unitSuffix}`;
                    };
                }

                chartInstance = new Chart(ctx, { type: type || 'bar', data: { labels, datasets }, 
                plugins: chartType === 'minsPerInterruption' ? [maxLinePlugin] : [],
                options: { responsive: true, maintainAspectRatio: false, interaction: { mode: 'index', intersect: false },
                scales: { 
                    x: { stacked }, 
                    y: yAxisOptions 
                }, 
                plugins: { 
                    legend: { 
                        labels: { 
                            generateLabels: function(chart) {
                                const originalLabels = Chart.defaults.plugins.legend.labels.generateLabels(chart);
                                originalLabels.forEach(label => {
                                    if (label.text === 'Max') {
                                        label.fillStyle = 'rgba(0,0,0,0)';
                                        label.strokeStyle = 'black';
                                        label.lineWidth = 2;
                                    }
                                });
                                return originalLabels;
                            }
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                if (chartType === 'completedSessions' && tooltipData) {
                                    const data = tooltipData[context.dataIndex];
                                    return `${context.dataset.label}: ${context.parsed.y.toFixed(0)}% (${data.completed}/${data.goal})`;
                                }
                                let val = context.raw;
                                if (val === null || isNaN(val)) return '';

                                if (chartType === 'interruptionLikelihood') {
                                    return `${context.dataset.label}: ${val.toFixed(2)} avg interruptions`;
                                }
                                
                                if (['avgDailyFocusTime', 'totalFocusTime', 'minsPerInterruption'].includes(chartType)) {
                                    const totalMinutes = val / 60;
                                    if (totalMinutes >= 60) {
                                        const hours = Math.floor(totalMinutes / 60);
                                        const minutes = Math.floor(totalMinutes % 60);
                                        return `${context.dataset.label}: ${hours}h ${minutes}m`;
                                    }
                                    return `${context.dataset.label}: ${Math.floor(totalMinutes)}m`;
                                }
                                return `${context.dataset.label}: ${context.parsed.y.toFixed(1)}${unitSuffix}`;
                            }
                        }
                    }
                }}});
            }
        }
        
        function getChartData(viewType, chartType) {
            let labels, ranges; 

            function getPeriods(vType) {
                vType = vType || 'day'; 
                const periods = { day: 7, week: 12, month: 12, year: 5 };
                const num = periods[vType];
                let labels = [], ranges = [];
                
                if (vType === 'day') {
                    let workDays = [];
                    let dayIterator = new Date(); dayIterator.setHours(12,0,0,0);
                    for (let i = 0; workDays.length < num && i < 365; i++) {
                        const cur = new Date(dayIterator);
                        cur.setDate(dayIterator.getDate() - i); 
                        const str = getLocalDateString(cur);
                        if (!isDayOff(str)) { workDays.unshift(cur);
                        }
                    }
                    labels = workDays.map(d => d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }));
                    ranges = workDays.map(d => ({s: d, e: d}));
                } else {
                    let allRanges = [];
                    let todayForRanges = new Date(); todayForRanges.setHours(12,0,0,0);
                    for (let i = num - 1; i >= 0; i--) {
                        let s, e, label;
                        if (vType === 'week') {
                            const weekStartsOn = userSettings.weekStartsOn || 0;
                            
                            const todayStr = getLocalDateString(todayForRanges); 
                            const todayAtUtcNoon = new Date(todayStr + 'T12:00:00Z'); 
                            const dayOfWeek = todayAtUtcNoon.getUTCDay(); 
                            
                            const dayOffset = (weekStartsOn === 1) 
                                ? (dayOfWeek === 0 ? 6 : dayOfWeek - 1) 
                                : dayOfWeek;
                                
                            s = new Date(todayForRanges);
                            s.setHours(0, 0, 0, 0); 
                            s.setDate(todayForRanges.getDate() - (i * 7) - dayOffset);
                            e = new Date(s); e.setDate(s.getDate() + 6);
                            label = `W of ${s.toLocaleDateString('en-US',{month:'short',day:'numeric'})}`;
                        } else if (vType === 'month') {
                            s = new Date(todayForRanges.getFullYear(), todayForRanges.getMonth() - i, 1);
                            e = new Date(todayForRanges.getFullYear(), todayForRanges.getMonth() - i + 1, 0);
                            label = s.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                        } else {
                            const y = todayForRanges.getFullYear() - i;
                            s = new Date(y, 0, 1); e = new Date(y, 11, 31); label = y.toString();
                        }
                        e.setHours(23, 59, 59, 999);
                        allRanges.push({ s, e, label });
                    }
                    labels = allRanges.map(r => r.label);
                    ranges = allRanges.map(r => ({s: r.s, e: r.e}));
                }
                return { labels, ranges };
            };
            
            if (chartType === 'reasonBubbleChart') {
                const startDate = document.getElementById('reasonRangeStart').value;
                const endDate = document.getElementById('reasonRangeEnd').value;
                
                if (!startDate || !endDate) {
                    return { labels: [], datasets: [] };
                }
                
                const s = new Date(startDate + 'T00:00:00');
                const e = new Date(endDate + 'T23:59:59');
                
                labels = ['Reason Data']; 
                ranges = [{ s, e }];
                
            } else if (chartType !== 'interruptionLikelihood') {
                const periods = getPeriods(viewType);
                labels = periods.labels;
                ranges = periods.ranges;
            }

            let firstTrackedDate = null;
            const allDates = Object.keys(focusedTimeData).sort();
            if (allDates.length > 0) {
                firstTrackedDate = new Date(allDates[0] + 'T00:00:00');
            }

            if (chartType === 'minsPerInterruption') {
                let firstInterruptionDate = null;
                for (const date of allDates) {
                    const sessions = focusedTimeData[date]?.sessions || [];
                    if (sessions.some(s => s.interruptions && s.interruptions.length > 0)) {
                        firstInterruptionDate = new Date(date + 'T00:00:00');
                        break;
                    }
                }
                if (firstInterruptionDate) {
                    firstTrackedDate = firstInterruptionDate;
                } else {
                    return { labels: [], datasets: [] }; 
                }
            }

            if (firstTrackedDate && chartType !== 'interruptionLikelihood') {
                const filtered = ranges.map((r, i) => ({r, l: labels[i]})).filter(item => item.r.e >= firstTrackedDate);
                ranges = filtered.map(item => item.r);
                labels = filtered.map(item => item.l);
            }
            
            const calculateTrend = (data) => {
                const validPoints = data.map((y, x) => ({ x, y })).filter(p => p.y !== null && p.y >= 0 && Number.isFinite(p.y));

                if (validPoints.length === 1) {
                    const trendValue = validPoints[0].y;
                    return data.map(d => d !== null ? trendValue : null);
                }

                if (validPoints.length < 2) return Array(data.length).fill(null);
                
                let sX=0, sY=0, sXY=0, sXX=0, n=validPoints.length;
                validPoints.forEach(p => { sX += p.x; sY += p.y; sXY += p.x*p.y; sXX += p.x*p.x; });
                const m = (n*sXX - sX*sX) !== 0 ? (n*sXY - sX*sY) / (n*sXX - sX*sX) : 0;
                const b = (sY/n) - (m*sX/n);
                return data.map((val, x) => {
                    if (val === null) return null;
                    const trendVal = m * x + b;
                    return trendVal >= 0 ? trendVal : null;
                });
            };

            if (chartType === 'reasonBubbleChart') {
                const stats = {};
                
                if (ranges && ranges.length > 0) {
                    const today = new Date();
                    today.setHours(23, 59, 59, 999);
                    
                    const r = ranges[0]; 
                    
                    const loopEndDate = r.e > today ? today : r.e;
                    const loopStartDate = firstTrackedDate && r.s < firstTrackedDate ? firstTrackedDate : r.s;

                    for (let d = new Date(loopStartDate); d <= loopEndDate; d.setDate(d.getDate() + 1)) {
                        const dStr = getLocalDateString(d);
                        
                        if (!isDayOff(dStr)) {
                            (focusedTimeData[dStr]?.sessions || []).forEach(s => {
                                if (s.reason) {
                                    if (!stats[s.reason]) { stats[s.reason] = { count: 0 }; }
                                    stats[s.reason].count++;
                                }
                            });
                        }
                    }
                }
                const labels = Object.keys(stats); 
                const data = labels.map(r => ({ x: Math.random() * 100, y: Math.random() * 100, r: stats[r].count * 4 + 5, rawCount: stats[r].count }));
                return { labels, data };
            }
            
             if (chartType === 'interruptionLikelihood') {
                try {
                    const range1Start = document.getElementById('range1Start').value;
                    const range1End = document.getElementById('range1End').value;
                    if (!range1Start || !range1End) return { labels: [], datasets: [] };
                    
                    const binSize = 15 * 60; 

                    const isComparing = document.getElementById('compareToggle').checked;
                    const range2Start = document.getElementById('range2Start').value;
                    const range2End = document.getElementById('range2End').value;
                    if (isComparing && (!range2Start || !range2End)) return { labels: [], datasets: [] };
                    const period1Label = `${new Date(range1Start+'T12:00').toLocaleDateString('default', {month:'short', day:'numeric'})} - ${new Date(range1End+'T12:00').toLocaleDateString('default', {month:'short', day:'numeric'})}`;
                    
                    const getSessionsInRange = (start, end) => {
                        const sessions = [];
                        for (let d = new Date(start + 'T12:00'); d <= new Date(end + 'T12:00'); d.setDate(d.getDate() + 1)) {
                            const dStr = getLocalDateString(d);
                            const daySessions = focusedTimeData[dStr]?.sessions || [];
                            daySessions.forEach(s => {
                                if (s.duration > 0 && !s.isManual) { 
                                    sessions.push(s);
                                }
                            });
                        }
                        return sessions;
                    };

                    const calculateLikelihood = (sessions) => {
                        if (sessions.length === 0) return { bins: {}, labels: [] };

                        const allDurations = sessions.map(s => s.duration);
                        const maxTime = Math.max(...allDurations, 15 * 60);
                        const numBins = Math.ceil(maxTime / binSize);
                        
                        let bins = {};
                        
                        for (let i = 0; i < numBins; i++) {
                            const binStart = i * binSize;
                            const binEnd = (i + 1) * binSize;
                            const formatLabelPart = (seconds) => {
                                const hours = seconds / 3600;
                                if (Number.isInteger(hours)) return `${hours}h`;
                                if (seconds % 3600 !== 0 && hours > 1) return `${parseFloat(hours.toFixed(2))}h`;
                                return `${seconds / 60}m`;
                            };
                            const key = `${formatLabelPart(binStart)}-${formatLabelPart(binEnd)}`;
                            bins[key] = { interruptions: 0, totalTime: 0 };
                        }
                        
                        const parseKeyForSort = (key) => {
                            const startPart = key.split('-')[0];
                            const val = parseFloat(startPart);
                            return startPart.includes('h') ? val * 3600 : val * 60;
                        };
                        const sortedBinLabels = Object.keys(bins).sort((a,b) => parseKeyForSort(a) - parseKeyForSort(b));

                        sessions.forEach(session => {
                            let remainingDuration = session.duration;
                            for (let i = 0; i < sortedBinLabels.length; i++) {
                                if (remainingDuration <= 0) break;
                                const timeInThisBin = Math.min(remainingDuration, binSize);
                                bins[sortedBinLabels[i]].totalTime += timeInThisBin;
                                remainingDuration -= timeInThisBin;
                            }

                            (session.interruptions || []).forEach(interruption => {
                                const timestamp = typeof interruption === 'number' ? interruption : interruption.time;
                                const binIndex = Math.floor(timestamp / binSize);
                                if (binIndex < sortedBinLabels.length) {
                                    bins[sortedBinLabels[binIndex]].interruptions++;
                                }
                            });
                        });
                        return { bins, labels: sortedBinLabels };
                    };
                    
                    const { bins: bins1, labels: labels1 } = calculateLikelihood(getSessionsInRange(range1Start, range1End));
                    
                    let datasets = [];
                    let allLabels = [...labels1];

                    const data1 = allLabels.map(key => {
                        const bin = bins1[key];
                        if (!bin || bin.totalTime === 0) return 0;
                        return (bin.interruptions / (bin.totalTime / binSize));
                    });

                    datasets.push({ label: period1Label, data: data1, type: 'line', borderColor: '#3B82F6', tension: 0.1 });
                    
                    if (isComparing) {
                        const period2Label = `${new Date(range2Start+'T12:00').toLocaleDateString('default', {month:'short', day:'numeric'})} - ${new Date(range2End+'T12:00').toLocaleDateString('default', {month:'short', day:'numeric'})}`;
                        const { bins: bins2, labels: labels2 } = calculateLikelihood(getSessionsInRange(range2Start, range2End));
                        
                        const parseKeyForSort = (key) => {
                             const startPart = key.split('-')[0];
                            const val = parseFloat(startPart);
                            return startPart.includes('h') ? val * 3600 : val * 60;
                        };
                        const allBinKeys = [...new Set([...allLabels, ...labels2])].sort((a,b) => parseKeyForSort(a) - parseKeyForSort(b));
                        allLabels = allBinKeys;
                        
                        const fullData1 = allLabels.map(key => {
                            const bin = bins1[key];
                            if (!bin || bin.totalTime === 0) return 0;
                            return (bin.interruptions / (bin.totalTime / binSize));
                        });

                        const data2 = allLabels.map(key => {
                            const bin = bins2[key];
                            if (!bin || bin.totalTime === 0) return 0;
                           return (bin.interruptions / (bin.totalTime / binSize));
                        });

                        datasets[0].data = fullData1;
                        datasets.push({ label: period2Label, data: data2, type: 'line', borderColor: '#EF4444', tension: 0.1 });
                    }

                    if (allLabels.length === 0) return { labels:[], datasets:[]};
                    return { labels: allLabels, datasets, unitSuffix: ' avg int.' };

                } catch(e) {
                     console.error("Error generating comparison chart:", e);
                     return { labels: [], datasets: [] };
                }
            }
            
            if (chartType === 'completedSessions') {
                let filteredLabels = [], percentages = [], tooltipDataArr = [];
                let rangesForFilteredLabels = []; 
                labels.forEach((label, i) => {
                    const r = ranges[i];
                    let totalCompleted = 0, totalGoal = 0, workDays = 0;
                    for (let d = new Date(r.s); d <= r.e; d.setDate(d.getDate() + 1)) {
                        const dStr = getLocalDateString(d);
                        if (!isDayOff(dStr)) {
                            workDays++;
                            totalGoal += goals[dStr]?.scheduledSessionsGoal ?? 0;
                            totalCompleted += (focusedTimeData[dStr]?.sessions || []).filter(s => s.type === 'countdown').length;
                        }
                    }
                    if (workDays > 0 && totalGoal > 0) {
                        filteredLabels.push(label);
                        percentages.push(Math.min(100, (totalCompleted / totalGoal) * 100));
                        tooltipDataArr.push({ completed: totalCompleted, goal: totalGoal });
                        rangesForFilteredLabels.push(r); 
                    }
                });
                if (filteredLabels.length === 0) return { labels: [], datasets:[]};
                
                let percentagesForTrend = [...percentages];
                if (percentagesForTrend.length > 0) {
                    const lastRange = rangesForFilteredLabels[rangesForFilteredLabels.length - 1];
                    const todayStr = getLocalDateString(new Date());
                    const today = new Date(todayStr + 'T12:00:00Z');
                    let excludeLastPoint = false;

                    if (viewType === 'day') {
                        const lastDateStr = getLocalDateString(lastRange.e);
                        if (lastDateStr === todayStr && !isDayOff(todayStr)) {
                            excludeLastPoint = true;
                        }
                    } else {
                        const lastRangeStart = new Date(lastRange.s); lastRangeStart.setHours(0,0,0,0);
                        const lastRangeEnd = new Date(lastRange.e); lastRangeEnd.setHours(23,59,59,999);
                        const isCurrentPeriod = today.getTime() >= lastRangeStart.getTime() && today.getTime() <= lastRangeEnd.getTime();
                        
                        if (isCurrentPeriod) {
                            let allRemainingDaysAreOff = true;
                            for (let d = new Date(today); d.getTime() <= lastRangeEnd.getTime(); d.setDate(d.getDate() + 1)) {
                                if (!isDayOff(getLocalDateString(d))) {
                                    allRemainingDaysAreOff = false;
                                    break;
                                }
                            }
                            if (!allRemainingDaysAreOff) {
                                excludeLastPoint = true;
                            }
                        }
                    }
                    if (excludeLastPoint) {
                        percentagesForTrend[percentagesForTrend.length - 1] = null;
                    }
                }
                const trendData = calculateTrend(percentagesForTrend);

                return { labels: filteredLabels, datasets: [
                    { label: '% Completed', data: percentages, backgroundColor: 'rgba(22, 163, 74, 0.7)', order: 2 },
                    { label: `Trend`, data: trendData, type: 'line', borderColor: '#EF4444', borderWidth: 2, pointRadius: 0, order: 1 }
                ], unitSuffix: '%', tooltipData: tooltipDataArr };
            }

            const calcVal = (d, t) => {
                const sessions = focusedTimeData[d]?.sessions || [];
                if (sessions.length === 0) return { value: 0, hasData: false };
                if (t === 'minsPerInterruption') {
                    const relevantSessions = sessions.filter(s => !s.isManual || (s.isManual && s.interruptions != null));
                    if (relevantSessions.length === 0) return { value: 0, hasData: false };
                    const duration = relevantSessions.reduce((sum, i) => sum + i.duration, 0);
                    const interruptions = relevantSessions.reduce((sum, i) => sum + ((i.interruptions?.length || 0)), 0);
                    return { value: duration > 0 ? duration / (interruptions + 1) : 0, hasData: true };
                }
                if (t === 'avgQuality') {
                    const r = sessions.filter(i => i.quality != null);
                    return { value: r.length > 0 ? r.reduce((sum, i) => sum + i.quality, 0) / r.length : 0, hasData: r.length > 0 };
                }
                return { value: sessions.reduce((sum, i) => sum + i.duration, 0), hasData: true };
            };

            let actualData = [], maxFocusData = [], filteredLabels = [], filteredRanges = [];
            ranges.forEach((r, i) => {
                let hasPeriodData = false;
                let workDaysInPeriod = 0;
                for (let d = new Date(r.s); d <= r.e; d.setDate(d.getDate() + 1)) {
                    const dStr = getLocalDateString(d);
                     if (!isDayOff(dStr)) {
                         workDaysInPeriod++;
                     }
                     if ((focusedTimeData[dStr]?.sessions || []).length > 0 && calcVal(dStr, chartType).hasData) {
                         hasPeriodData = true;
                     }
                }
                
                if ((hasPeriodData || ['avgDailyFocusTime', 'totalFocusTime'].includes(chartType)) && workDaysInPeriod > 0) {
                    filteredLabels.push(labels[i]);
                    filteredRanges.push(r);
                }
            });
            
            filteredRanges.forEach(r => {
                let val = 0, workDays = 0, maxFocus = 0;
                let daysWithMpiData = 0; 
                const today = new Date();
                today.setHours(23, 59, 59, 999);
                const loopEndDate = r.e > today ? today : r.e;
                const loopStartDate = firstTrackedDate && r.s < firstTrackedDate ? firstTrackedDate : r.s;

                for (let d = new Date(loopStartDate); d <= loopEndDate; d.setDate(d.getDate() + 1)) {
                    const dStr = getLocalDateString(d);
                    if (!isDayOff(dStr)) {
                        workDays++; 
                        const dailyCalc = calcVal(dStr, chartType);
                        
                        val += dailyCalc.value; 

                        if (chartType === 'minsPerInterruption') {
                            if (dailyCalc.hasData) { 
                                daysWithMpiData++;
                            }
                            maxFocus = Math.max(maxFocus, calculateMaxUninterruptedFocus(dStr, true));
                        }
                    }
                }

                let finalVal;
                if (viewType !== 'day' && chartType === 'avgDailyFocusTime') {
                    finalVal = workDays > 0 ? val / workDays : 0;
                } else if (viewType !== 'day' && chartType === 'minsPerInterruption') { 
                    finalVal = daysWithMpiData > 0 ? val / daysWithMpiData : 0; 
                } else {
                    finalVal = val;
                }
                
                actualData.push(finalVal);
                maxFocusData.push(maxFocus);
            });
            
            if (filteredLabels.length === 0) return { labels: [], datasets:[]};

            let unitSuffix = '‚≠ê';
            if (['avgDailyFocusTime', 'totalFocusTime', 'minsPerInterruption'].includes(chartType)) { unitSuffix = 's'; 
            }

            let trendData, maxTrend;
            let dataForTrend = [...actualData];
            let dataForTrendMax = [...maxFocusData]; 
            
            if ((chartType === 'avgDailyFocusTime' || chartType === 'totalFocusTime' || chartType === 'minsPerInterruption') && dataForTrend.length > 0) {
                const lastRange = filteredRanges[filteredRanges.length - 1];
                const todayStr = getLocalDateString(new Date());
                const today = new Date(todayStr + 'T12:00:00Z'); 
                let excludeLastPoint = false;

                if (viewType === 'day') {
                    const lastDateStr = getLocalDateString(lastRange.e);
                    if (lastDateStr === todayStr && !isDayOff(todayStr)) {
                         excludeLastPoint = true;
                    }
                } else {
                    const lastRangeStart = new Date(lastRange.s); lastRangeStart.setHours(0,0,0,0);
                    const lastRangeEnd = new Date(lastRange.e); lastRangeEnd.setHours(23,59,59,999);
                    
                    const isCurrentPeriod = today.getTime() >= lastRangeStart.getTime() && today.getTime() <= lastRangeEnd.getTime();
                    
                    if (isCurrentPeriod) {
                        let allRemainingDaysAreOff = true;
                        
                        for (let d = new Date(today); d.getTime() <= lastRangeEnd.getTime(); d.setDate(d.getDate() + 1)) {
                            const dStr = getLocalDateString(d);
                            if (!isDayOff(dStr)) {
                                allRemainingDaysAreOff = false;
                                break;
                            }
                        }
                        
                        if (!allRemainingDaysAreOff) {
                            excludeLastPoint = true;
                        }
                    }
                }
                
                if (excludeLastPoint) {
                    dataForTrend[dataForTrend.length - 1] = null;
                    if (chartType === 'minsPerInterruption') {
                        dataForTrendMax[dataForTrendMax.length - 1] = null;
                    }
                }
            }
            
            trendData = calculateTrend(dataForTrend);
            
            maxTrend = calculateTrend(dataForTrendMax); 
            let datasets;
             if (chartType === 'minsPerInterruption') {
                datasets = [
                    { label: `Avg`, data: actualData, backgroundColor: 'rgba(59, 130, 246, 0.7)', order: 4 },
                    { label: `Max`, data: maxFocusData, type: 'line', radius: 5, pointHitRadius: 20, backgroundColor: 'transparent', borderColor: 'transparent', order: 2 },
                    { label: `Trend`, data: trendData, type: 'line', borderColor: '#EF4444', borderWidth: 2, pointRadius: 0, order: 3 },
                    { label: `Max Trend`, data: maxTrend, type: 'line', borderColor: 'grey', borderDash: [5, 5], borderWidth: 2, pointRadius: 0, order: 1 }
                ];
            } else {
                datasets = [
                    { label: `Actual`, data: actualData, backgroundColor: 'rgba(59, 130, 246, 0.7)', order: 2 },
                    { label: `Trend`, data: trendData, type: 'line', borderColor: '#EF4444', borderWidth: 2, pointRadius: 0, order: 1 }
                ];
            }
            
            return { labels: filteredLabels, datasets, unitSuffix, type: 'bar', stacked: false };
        }
        
        function renderLog() {
            const logDiv = document.getElementById('logEntries'), moreBtn = document.getElementById('showMoreLogBtn');
            logDiv.innerHTML = ''; const entries = Object.entries(focusedTimeData).flatMap(([d, data]) => (data.sessions || []).map(s => ({...s, date: d }))).sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            if (entries.length === 0) { logDiv.innerHTML = '<p class="text-center text-gray-500">No entries yet.</p>'; moreBtn.classList.add('hidden'); return;
            }
            const toShow = showAllLogEntries ? entries : entries.slice(0, 5);
            toShow.forEach(e => {
                const s = e.quality ? Array(Math.round(e.quality)).fill('<i class="fa-solid fa-star log-star"></i>').join('') : 'No rating';
                const interruptionCount = e.interruptions?.length || 0;
                const logItem = document.createElement('div'); logItem.className = 'log-entry-item';
                logItem.innerHTML = `<span>${e.date} at ${new Date(e.timestamp).toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'})}</span><span class="flex items-center gap-2">${formatTimer(e.duration)} (${interruptionCount} int.) <span class="text-yellow-500 flex items-center">${s}</span></span><div class="space-x-2"><button class="text-sm text-blue-600 hover:underline edit-btn" data-date="${e.date}" data-session-id="${e.id}">Edit</button><button class="text-sm text-red-600 hover:underline delete-btn" data-date="${e.date}" data-session-id="${e.id}">Delete</button></div>`;
                logDiv.appendChild(logItem);
            });
            moreBtn.style.display = entries.length > 5 ? 'block' : 'none'; moreBtn.textContent = showAllLogEntries ? 'Show Less' : 'Show More';
            document.querySelectorAll('.edit-btn').forEach(b => b.addEventListener('click', e => editSessionPrompt(e.target.dataset.date, e.target.dataset.sessionId)));
            document.querySelectorAll('.delete-btn').forEach(b => b.addEventListener('click', e => deleteSession(e.target.dataset.date, e.target.dataset.sessionId)));
        }
        
        async function deleteSession(date, sessionId) {
            if (!(await showConfirm('Delete this entry?'))) return;
            const updated = focusedTimeData[date].sessions.filter(s => s.id !== sessionId);
            try {
                const docRef = doc(db, `artifacts/${APP_ID_FOR_FIRESTORE}/users/${userId}/focusSessions`, date);
                if (updated.length > 0) { await updateDoc(docRef, { sessions: updated }); } else { await deleteDoc(docRef); 
                }
                showMessage('Entry deleted.');
            } catch (e) { showMessage('Error deleting entry.'); }
        }
        
        function editSessionPrompt(date, sessionId) {
            const session = focusedTimeData[date]?.sessions.find(s => s.id === sessionId);
            if (!session) return;
            const modal = document.getElementById('editLogModal');
            const h = Math.floor(session.duration/3600), m = Math.floor((session.duration%3600)/60), s = session.duration%60;
            const interruptionCount = session.interruptions?.length || 0;
            const isManualSession = session.isManual;
            const interruptionsInputHTML = isManualSession
                ? `<div class="mt-2"><label>Interruptions</label><input type="number" id="editInterruptions" value="${interruptionCount}" class="w-full p-2 border rounded"></div>`
                : `<div class="mt-2"><label>Interruptions (from timer)</label><input type="number" id="editInterruptions" value="${interruptionCount}" class="w-full p-2 border rounded bg-gray-100" disabled></div>`;
            modal.innerHTML = `<div class="modal-content"><h3 class="text-xl font-bold mb-4">Edit Entry</h3><div class="grid grid-cols-3 gap-2"><div><label>H</label><input type="number" id="editHours" value="${h}" class="w-full p-2 border rounded"></div><div><label>M</label><input type="number" id="editMinutes" value="${m}" class="w-full p-2 border rounded"></div><div><label>S</label><input type="number" id="editSeconds" value="${s}" class="w-full p-2 border rounded"></div></div>${interruptionsInputHTML}<div class="mt-2"><label>Quality</label><div class="star-rating flex justify-center mt-1" data-rating="${session.quality||0}" id="editStarRating"><i class="fa-solid fa-star" data-value="1"></i><i class="fa-solid fa-star" data-value="2"></i><i class="fa-solid fa-star" data-value="3"></i><i class="fa-solid fa-star" data-value="4"></i><i class="fa-solid fa-star" data-value="5"></i></div></div><div class="mt-4 flex justify-end space-x-2"><button id="cancelEditBtn" class="btn bg-gray-300">Cancel</button><button id="saveEditBtn" class="btn btn-blue">Save</button></div></div>`;
            modal.style.display = 'flex';
            
            const starContainer = modal.querySelector('#editStarRating');
            const stars = starContainer.querySelectorAll('.fa-star');
            const initialRating = session.quality || 0;
            stars.forEach(star => star.classList.toggle('selected', star.dataset.value <= initialRating));
            setupStarRating(starContainer);

            document.getElementById('saveEditBtn').onclick = () => {
                const newDur = (parseInt(document.getElementById('editHours').value)*3600) + (parseInt(document.getElementById('editMinutes').value)*60) + parseInt(document.getElementById('editSeconds').value);
                const newQuality = parseInt(starContainer.dataset.rating) || null;
                let updatedInterruptions;

                if (session.isManual) {
                    const newInt = parseInt(document.getElementById('editInterruptions').value);
                    updatedInterruptions = Array(newInt >= 0 ? newInt : 0).fill({ time: 0, penalty: 0 }); 
                } else {
                    const originalInterruptions = session.interruptions || [];
                    updatedInterruptions = originalInterruptions.filter(i => i.time <= newDur);
                }
                
                updateSession(date, sessionId, {duration: newDur, interruptions: updatedInterruptions, quality: newQuality});
                modal.style.display = 'none';
            };
            document.getElementById('cancelEditBtn').onclick = () => modal.style.display = 'none';
        }

        async function updateSession(date, id, updatedFields) {
            const updated = focusedTimeData[date].sessions.map(s => s.id === id ? { ...s, ...updatedFields } : s);
            try {
                await updateDoc(doc(db, `artifacts/${APP_ID_FOR_FIRESTORE}/users/${userId}/focusSessions`, date), { sessions: updated });
                showMessage('Updated.');
            } catch (e) { showMessage('Error updating.'); }
        }
        
        // --- Daily Timeline Rendering ---
		function renderDailyTimeline() {
			const container = document.getElementById('dailyTimeline');
			const markersContainer = document.getElementById('dailyTimelineMarkers');
			container.innerHTML = ''; 
			markersContainer.innerHTML = '';
			
			// 1. Update Date Display & Controls
			const dStr = getLocalDateString(timelineViewDate);
			const todayStr = getLocalDateString(new Date());
			const dateDisplay = document.getElementById('tlDateDisplay');
			const nextBtn = document.getElementById('tlNextDay');
			const jumpBtn = document.getElementById('tlJumpTodayBtn');

			if (dStr === todayStr) {
				dateDisplay.textContent = "Today";
				nextBtn.disabled = true;
				jumpBtn.classList.add('hidden'); // Hide jump button if already on today
			} else {
				dateDisplay.textContent = timelineViewDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
				nextBtn.disabled = false;
				jumpBtn.classList.remove('hidden'); // Show jump button
			}
			
			const sessions = focusedTimeData[dStr]?.sessions || [];

			// 2. Determine Time Range (Default 7am-7pm, or dynamic based on data)
			let minHour = 7; 
			let maxHour = 19; 

			if (sessions.length > 0) {
				if (sessions.length > 0) {
					const sessionStartHours = sessions.map(s => {
						const ts = new Date(s.timestamp);
						// If Manual OR New "Start Time" format: Timestamp is Start
						if (s.isManual || s.isStartTime) return ts.getHours();
						
						// Old Format: Timestamp is End, so subtract duration
						const durationMs = s.totalSessionDuration || (s.duration * 1000);
						return new Date(ts.getTime() - durationMs).getHours();
				});
				const sessionEndHours = sessions.map(s => {
					const ts = new Date(s.timestamp);
					const durationMs = s.totalSessionDuration || (s.duration * 1000);
					
					// If Manual OR New "Start Time" format: Start + Duration = End
					if (s.isManual || s.isStartTime) {
						 const end = new Date(ts.getTime() + durationMs);
						 return end.getHours() + (end.getMinutes() > 0 ? 1 : 0);
					}
					
					// Old Format: Timestamp is already End
					return ts.getHours() + (ts.getMinutes() > 0 ? 1 : 0);
				});
				
				const dataMin = Math.min(...sessionStartHours);
				const dataMax = Math.max(...sessionEndHours);

				// Expand range if data is outside default window with 1h buffer
				minHour = Math.min(minHour, Math.max(0, dataMin - 1));
				maxHour = Math.max(maxHour, Math.min(24, dataMax + 1));
			}

			// Ensure valid range
			if (maxHour <= minHour) maxHour = minHour + 1;
			const totalHoursInRange = maxHour - minHour;
			
			// 3. Render Markers
			const isMobile = window.innerWidth < 768;
			// Desktop: Every 1 hour. Mobile: Every 2 or 3 hours depending on density
			const markerInterval = isMobile ? (totalHoursInRange > 12 ? 3 : 2) : 1; 

			for (let h = minHour; h <= maxHour; h += markerInterval) {
				const percent = ((h - minHour) / totalHoursInRange) * 100;
				
				if (percent >= 0 && percent <= 100) {
					// Label
					const label = document.createElement('div');
					label.className = 'daily-timeline-marker-label';
					label.style.left = `${percent}%`;
					label.textContent = `${String(h).padStart(2, '0')}:00`;
					markersContainer.appendChild(label);

					// Grid Line
					const line = document.createElement('div');
					line.className = 'daily-timeline-marker-line';
					line.style.left = `${percent}%`;
					container.appendChild(line);
				}
			}

			if (sessions.length === 0) {
				const emptyMsg = document.createElement('div');
				emptyMsg.textContent = "No focus data for this day";
				emptyMsg.className = "absolute w-full text-center text-xs text-gray-400 mt-2 top-1/2 transform -translate-y-1/2";
				container.appendChild(emptyMsg);
				return;
			}
			
			// 4. Render Sessions
            sessions.forEach(session => {
                // --- STRATEGY: Determine the actual Start Time ---
                const ts = new Date(session.timestamp);
                const totalDurationMs = session.totalSessionDuration || (session.duration * 1000);
                
                let sessionStart;
                // If it's a Manual entry OR it has our new "isStartTime" flag, timestamp IS the start.
                // Otherwise, it's an old timer entry where timestamp was the END, so we subtract duration.
                if (session.isManual || session.isStartTime) {
                    sessionStart = ts;
                } else {
                    sessionStart = new Date(ts.getTime() - totalDurationMs);
                }
                
                const startTotalMinutes = (sessionStart.getHours() * 60) + sessionStart.getMinutes();
                const startRelativeMinutes = startTotalMinutes - (minHour * 60);
                
                // Helper: Convert minutes to % width
                const getPercent = (mins) => (mins / (totalHoursInRange * 60)) * 100;
                const getStartPercent = (offsetMins) => ((startRelativeMinutes + offsetMins) / (totalHoursInRange * 60)) * 100;

                // --- Manual Entries (Simple Block) ---
                if (session.isManual) {
                    const durationMinutes = session.duration / 60;
                    const bar = document.createElement('div');
                    bar.className = 'daily-timeline-segment timeline-manual-segment';
                    bar.style.left = `${getStartPercent(0)}%`;
                    bar.style.width = `${getPercent(durationMinutes)}%`;
                    
                    const timeStr = sessionStart.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                    bar.title = `Manual Entry\n${timeStr}\nDuration: ${Math.round(durationMinutes)}m`;
                    
                    container.appendChild(bar);
                    return; 
                }

                // --- Timer Entries (Complex: Focus, Breaks, Penalties) ---
                let points = new Set([0, totalDurationMs / 1000]); // seconds relative to start
                
                const pauseEvents = session.pauseEvents || [];
                pauseEvents.forEach(p => {
                    if (p.start != null) points.add(p.start);
                    if (p.end != null) points.add(p.end);
                });

                const interruptions = session.interruptions || [];
                const normalizedInterruptions = interruptions.map(i => (typeof i === 'number') ? { time: i, penalty: 0 } : i);
                
                normalizedInterruptions.forEach(i => {
                    points.add(i.time); 
                    points.add(i.time - i.penalty); // Start of penalty 
                });

                const sortedPoints = Array.from(points).sort((a, b) => a - b);

                for (let i = 0; i < sortedPoints.length - 1; i++) {
                    const segStart = sortedPoints[i];
                    const segEnd = sortedPoints[i+1];
                    const segDuration = segEnd - segStart;
                    const segMid = segStart + (segDuration / 2);

                    if (segDuration <= 1) continue; 

                    let type = 'focus'; 
                    
                    const isBreak = pauseEvents.some(p => segMid >= p.start && segMid < p.end);
                    if (isBreak) type = 'break';

                    const isPenalty = normalizedInterruptions.some(int => segMid >= (int.time - int.penalty) && segMid < int.time);
                    if (isPenalty) type = 'penalty';

                    const el = document.createElement('div');
                    el.className = `daily-timeline-segment timeline-${type}-segment`;
                    
                    const offsetMinutes = segStart / 60;
                    const widthMinutes = segDuration / 60;

                    el.style.left = `${getStartPercent(offsetMinutes)}%`;
                    el.style.width = `${getPercent(widthMinutes)}%`;
                    
                    const startTimeStr = new Date(sessionStart.getTime() + segStart * 1000).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
                    el.title = `${type.charAt(0).toUpperCase() + type.slice(1)}\n${startTimeStr}\n${Math.round(widthMinutes * 10) / 10} min`;

                    container.appendChild(el);
                }
            });
		}
        
        function setupEventListeners() {
            // --- Auth ---
            const authEmail=document.getElementById('authEmail'), authPassword=document.getElementById('authPassword'), authError=document.getElementById('authErrorMessage');
            document.getElementById('signInBtn').addEventListener('click', () => { authError.textContent = ''; signInWithEmailAndPassword(auth, authEmail.value, authPassword.value).catch(e => authError.textContent = e.message); });
            document.getElementById('createAccountBtn').addEventListener('click', () => { authError.textContent = ''; createUserWithEmailAndPassword(auth, authEmail.value, authPassword.value).catch(e => authError.textContent = e.message); });
            document.getElementById('anonymousSignInBtn').addEventListener('click', () => { authError.textContent = ''; signInAnonymously(auth).catch(e => authError.textContent = e.message); });
            
            // --- Timer ---
            document.getElementById('togglePauseBtn').addEventListener('click', toggleTimer);
            document.getElementById('endFocusBtn').addEventListener('click', () => handleEndFocus(false));
            document.getElementById('logInterruptionBtn').addEventListener('click', () => {
                const penaltyInput = document.getElementById('penaltyMinutesInput');
                const label = document.querySelector('label[for="penaltyMinutesInput"]');
                const elapsedSecondsSinceLastEvent = running && lastPenaltyResetTime ? (Date.now() - lastPenaltyResetTime) / 1000 : 0;
                const maxMinutes = Math.floor(elapsedSecondsSinceLastEvent / 60);
                penaltyInput.max = maxMinutes;
                label.textContent = `Interruption Duration (max: ${maxMinutes})`;
                
                document.getElementById('logInterruptionModal').style.display = 'flex';
            });
            document.querySelectorAll('.timer-mode-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    if (running) { showMessage("Please end the current session before switching modes."); return; }
                    document.querySelectorAll('.timer-mode-btn').forEach(b => b.classList.remove('active')); e.currentTarget.classList.add('active');
                    currentTimerMode = e.currentTarget.id === 'stopwatchModeBtn' ? 'stopwatch' : 'countdown';
                    document.getElementById('timerModeDescription').textContent = currentTimerMode === 'stopwatch' ? 'Stopwatch' : 'Countdown';
                    resetTimerState(); renderChart(); 
                });
            });

            // --- Toggles ---
            document.getElementById('notificationToggle').addEventListener('change', e => { notificationsEnabled = e.target.checked; localStorage.setItem('notificationToggleState', String(e.target.checked)); if(e.target.checked) { Notification.requestPermission(); } });
            document.getElementById('focusMusicToggle').addEventListener('change', e => { focusMusicEnabled = e.target.checked; localStorage.setItem('focusMusicToggleState', String(e.target.checked)); });
            
            // --- Chart Controls ---
            document.querySelectorAll('#chartViewControls .view-btn').forEach(b => b.addEventListener('click', e => { document.querySelectorAll('#chartViewControls .view-btn').forEach(i => i.classList.remove('active')); e.currentTarget.classList.add('active'); renderChart(); }));
            
            document.getElementById('chartTypeSelect').addEventListener('change', (e) => {
                const chartType = e.target.value;
                const defaultControls = document.getElementById('chartViewControls');
                const comparisonControls = document.getElementById('comparisonControls');
                const reasonControls = document.getElementById('reasonChartControls'); 

                if (chartType === 'interruptionLikelihood') {
                    defaultControls.classList.add('hidden');
                    comparisonControls.classList.remove('hidden');
                    reasonControls.classList.add('hidden'); 
                    setupComparisonControls();
                } else if (chartType === 'reasonBubbleChart') {
                    defaultControls.classList.add('hidden');
                    comparisonControls.classList.add('hidden');
                    reasonControls.classList.remove('hidden'); 
                    setupReasonChartControls(); 
                } else {
                    defaultControls.classList.remove('hidden');
                    comparisonControls.classList.add('hidden');
                    reasonControls.classList.add('hidden'); 
                    renderChart(); 
                }
            });
            
            ['range1Start', 'range1End', 'range2Start', 'range2End', 'compareToggle'].forEach(id => {
                document.getElementById(id).addEventListener('change', () => {
                    if (id === 'compareToggle') {
                        document.getElementById('period2Container').classList.toggle('hidden', !document.getElementById('compareToggle').checked);
                    }
                    renderChart();
                });
            });

            ['reasonRangeStart', 'reasonRangeEnd'].forEach(id => {
                document.getElementById(id).addEventListener('change', renderChart);
            });

            // --- Timeline Navigation ---
            document.getElementById('tlPrevDay').addEventListener('click', () => { timelineViewDate.setDate(timelineViewDate.getDate() - 1); renderDailyTimeline(); });
            document.getElementById('tlNextDay').addEventListener('click', () => { timelineViewDate.setDate(timelineViewDate.getDate() + 1); renderDailyTimeline(); });
			document.getElementById('tlJumpTodayBtn').addEventListener('click', () => { 
				timelineViewDate = new Date(); 
				renderDailyTimeline(); 
			});

            // --- Log & Calendar ---
            document.getElementById('showMoreLogBtn').addEventListener('click', () => { showAllLogEntries = !showAllLogEntries; renderLog(); });
            
            // Manual Entry Logic
            const startTimeInput = document.getElementById('newEntryStartTime');
            const endTimeInput = document.getElementById('newEntryEndTime');
            const hoursInput = document.getElementById('newEntryHours');
            const minutesInput = document.getElementById('newEntryMinutes');

            function updateDurationFromTime() {
                if(startTimeInput.value && endTimeInput.value) {
                    const start = new Date(`1970-01-01T${startTimeInput.value}:00`);
                    let end = new Date(`1970-01-01T${endTimeInput.value}:00`);
                    if (end < start) end.setDate(end.getDate() + 1); // Handle overnight
                    
                    const diffMs = end - start;
                    const totalMins = Math.floor(diffMs / 60000);
                    const h = Math.floor(totalMins / 60);
                    const m = totalMins % 60;
                    
                    hoursInput.value = h;
                    minutesInput.value = m;
                }
            }

            function updateEndFromDuration() {
                if (startTimeInput.value) {
                    const start = new Date(`1970-01-01T${startTimeInput.value}:00`);
                    const h = parseInt(hoursInput.value) || 0;
                    const m = parseInt(minutesInput.value) || 0;
                    
                    start.setHours(start.getHours() + h);
                    start.setMinutes(start.getMinutes() + m);
                    
                    // Format to HH:MM
                    const hh = String(start.getHours()).padStart(2, '0');
                    const mm = String(start.getMinutes()).padStart(2, '0');
                    endTimeInput.value = `${hh}:${mm}`;
                }
            }

            startTimeInput.addEventListener('change', () => {
                if (endTimeInput.value) updateDurationFromTime();
                else updateEndFromDuration();
            });
            endTimeInput.addEventListener('change', updateDurationFromTime);
            hoursInput.addEventListener('input', updateEndFromDuration);
            minutesInput.addEventListener('input', updateEndFromDuration);

            document.getElementById('addEntryBtn').addEventListener('click', async () => {
                const d = document.getElementById('newEntryDate').value;
                const h = parseInt(document.getElementById('newEntryHours').value)||0;
                const m = parseInt(document.getElementById('newEntryMinutes').value)||0;
                const startT = document.getElementById('newEntryStartTime').value;
                
                const intVal = document.getElementById('newEntryInterruptions').value;
                const interruptions = intVal !== '' && Number(intVal) >= 0 ? Array(parseInt(intVal)).fill({ time: 0, penalty: 0 }) : null;
                const q = parseInt(document.getElementById('newEntryStarRating').dataset.rating) || null;
                if (!d || (h === 0 && m === 0)) { showMessage("Date and duration required."); return; }
                
                const totalEntriesBeforeAdding = Object.values(focusedTimeData).reduce((sum, day) => sum + (day.sessions?.length || 0), 0);
                const isFirstEver = totalEntriesBeforeAdding === 0;

                // Determine timestamp. Default to 12:00 if no start time given
                let timestampStr;
                if (startT) {
                    timestampStr = new Date(`${d}T${startT}:00`).toISOString();
                } else {
                    timestampStr = new Date(d+'T12:00:00').toISOString();
                }

                const newS = { id: crypto.randomUUID(), duration: (h*3600)+(m*60), interruptions, quality: q, timestamp: timestampStr, type: 'stopwatch', isManual: true };
                
                if (!focusedTimeData[d]) focusedTimeData[d] = { sessions: [] };
                focusedTimeData[d].sessions.push(newS);
                debounceUpdateUI();

                try {
                    const docRef = doc(db, `artifacts/${APP_ID_FOR_FIRESTORE}/users/${userId}/focusSessions`, d);
                    const docSnap = await getDoc(docRef);
                    const existing = docSnap.exists() && docSnap.data().sessions ? docSnap.data().sessions : [];
                    await setDoc(docRef, { sessions: [...existing, newS] }, { merge: true });

                    if (isFirstEver) {
                        const firstEntryDate = new Date(d); firstEntryDate.setHours(12, 0, 0, 0); 
                        const batch = writeBatch(db);
                        for (let i = 1; i <= 365; i++) { 
                            let pastDate = new Date(firstEntryDate);
                            pastDate.setDate(firstEntryDate.getDate() - i);
                            const dateStr = getLocalDateString(pastDate); 
                            const dayOfWeek = pastDate.getDay(); 
                            if ((dayOfWeek !== 0 && dayOfWeek !== 6) && !daysOff[dateStr]) { 
                                const dayOffDocRef = doc(db, `artifacts/${APP_ID_FOR_FIRESTORE}/users/${userId}/daysOff`, dateStr);
                                batch.set(dayOffDocRef, { isWorkDay: false });
                            }
                        }
                        await batch.commit();
                        showMessage("Entry added! Past weekdays have been marked as days off.");
                    } else {
                        showMessage("Entry added!");
                    }
                    // Clear inputs
                    hoursInput.value = 0; minutesInput.value = 0;
                    startTimeInput.value = ''; endTimeInput.value = '';
                } catch (e) {
                    showMessage("Error adding entry.");
                    focusedTimeData[d].sessions = focusedTimeData[d].sessions.filter(s => s.id !== newS.id);
                    debounceUpdateUI();
                }
            });
            document.getElementById('prevMonthBtn').addEventListener('click', () => { calendarDate.setMonth(calendarDate.getMonth() - 1); renderCalendar(); });
            document.getElementById('nextMonthBtn').addEventListener('click', () => { calendarDate.setMonth(calendarDate.getMonth() + 1); renderCalendar(); });
            setupStarRating(document.getElementById('newEntryStarRating'));

            // --- Goals ---
            document.getElementById('openGoalsModalBtn').addEventListener('click', openGoalsModal);
            document.getElementById('saveGoalsBtn').addEventListener('click', saveGoals);
            ['todayFocusGoal', 'scheduledSessionsGoal', 'interruptionGoal'].forEach(id => {
                document.getElementById(id).addEventListener('input', validateGoalInput);
            });
            
            // --- Modal Close Buttons ---
            document.querySelectorAll('.modal .close-button, .modal [id^=cancel], .modal [id=modalOkBtn]').forEach(b => b.addEventListener('click', e => e.currentTarget.closest('.modal').style.display = 'none'));
            
            // --- AI Insights Export ---
            document.getElementById('openAiExportBtn').addEventListener('click', () => {
                document.getElementById('settingsModal').style.display = 'none';
                document.getElementById('aiExportModal').style.display = 'flex';
                generateAIPrompt(); // Generate initial prompt
            });
            
            document.getElementById('aiHabitTrackerCheckbox').addEventListener('change', generateAIPrompt);
            
            document.getElementById('downloadDataBtn').addEventListener('click', downloadUserData);
            document.getElementById('downloadCodeBtn').addEventListener('click', downloadAppCode);
            document.getElementById('copyPromptBtn').addEventListener('click', () => {
                const text = document.getElementById('aiPromptText');
                text.select();
                document.execCommand('copy');
                document.getElementById('copyPromptBtn').textContent = 'Copied!';
                setTimeout(() => document.getElementById('copyPromptBtn').textContent = 'Copy Prompt', 2000);
            });

            // *NEW: AI Prompt Customization Listeners*
            document.getElementById('aiPromptText').addEventListener('input', (e) => {
                const val = e.target.value;
                debounceSaveSettings({ customAiPrompt: val }, 'aiPromptSaveStatus');
            });

            document.getElementById('resetPromptBtn').addEventListener('click', () => {
                if(confirm("Reset prompt to default? This will lose your custom edits.")) {
                    debounceSaveSettings({ customAiPrompt: null }, 'aiPromptSaveStatus');
                    userSettings.customAiPrompt = null;
                    generateAIPrompt();
                }
            });
            // *END NEW SECTION*

            // --- Countdown Modals ---
            document.getElementById('closeMedalModalBtn').addEventListener('click', () => {
                clearInterval(overtimeInterval); const overtimeMs = overtimeStartTime ? Date.now() - overtimeStartTime : 0;
                const addOvertime = document.getElementById('addOvertimeCheckbox').checked;
                const finalDuration = sessionDataForReflection.duration + (addOvertime ? overtimeMs : 0);
                document.getElementById('medalModal').style.display = 'none';
                
                const totalSessionDuration = sessionDataForReflection.totalSessionDuration + (addOvertime ? overtimeMs : 0);
                showReflectionModal({ ...sessionDataForReflection, duration: finalDuration, totalSessionDuration });
            });
            const countdownMinutesInput = document.getElementById('countdownMinutes');
            const startCountdownBtn = document.getElementById('startCountdownBtn');
            const countdownErrorEl = document.getElementById('countdownError');

            function validateCountdownLength() {
                const m = parseInt(countdownMinutesInput.value);
                const minLength = userSettings.minSessionLength;
                if (minLength && minLength > 0 && m < minLength) {
                    countdownErrorEl.textContent = `It takes time to build focus. Try a session of at least ${minLength} minutes.`;
                    startCountdownBtn.disabled = true;
                } else {
                    countdownErrorEl.textContent = '';
                    startCountdownBtn.disabled = false;
                }
            }
            countdownMinutesInput.addEventListener('input', validateCountdownLength);
            startCountdownBtn.addEventListener('click', () => {
                const m = parseInt(countdownMinutesInput.value);
                if (startCountdownBtn.disabled) { validateCountdownLength(); return; }
                breakInterval = parseInt(document.getElementById('breakIntervalMinutes').value) * 60 || 0;
                if (m > 0) { 
                    countdownDuration = m * 60; 
                    document.getElementById('countdownModal').style.display = 'none'; 
                    startTimer(); 
                }
            });
            document.getElementById('earlyEndYesBtn').addEventListener('click', () => { document.getElementById('earlyEndModal').style.display = 'none'; showReflectionModal(sessionDataForReflection); });
            document.getElementById('earlyEndNoCountBtn').addEventListener('click', () => { document.getElementById('earlyEndModal').style.display = 'none'; showReflectionModal({ ...sessionDataForReflection, type: 'stopwatch' }); });
            document.getElementById('earlyEndNoDiscardBtn').addEventListener('click', () => { document.getElementById('earlyEndModal').style.display = 'none'; resetTimerState(); });

            // --- Interruption/Pause Modals ---
            document.getElementById('justPauseBtn').addEventListener('click', () => { 
                pauseTimer(); 
                document.getElementById('interruptionPromptModal').style.display = 'none'; 
                if (focusMusicEnabled) launchSpotify();
            });
            document.getElementById('logInterruptionFromPauseBtn').addEventListener('click', () => { 
                pauseTimer(); 
                document.getElementById('interruptionPromptModal').style.display = 'none'; 
                document.getElementById('logInterruptionModal').style.display = 'flex'; 
            });
            document.getElementById('cancelPauseBtn').addEventListener('click', () => { document.getElementById('interruptionPromptModal').style.display = 'none'; });
            document.getElementById('confirmLogInterruptionBtn').addEventListener('click', () => {
                const penaltyInput = document.getElementById('penaltyMinutesInput');
                const statusEl = document.getElementById('penaltyErrorStatus');
                statusEl.textContent = '';
                let penaltyMinutes = parseInt(penaltyInput.value) || 0;

                const maxPenalty = parseInt(penaltyInput.max);
                if (penaltyMinutes > maxPenalty) {
                    statusEl.textContent = `Penalty cannot exceed elapsed time (max: ${maxPenalty} min)`;
                    setTimeout(() => statusEl.textContent = '', 3000);
                    return;
                }

                const wallClockTimeAtInterruption = sessionAbsoluteStartTime ? (Date.now() - sessionAbsoluteStartTime) / 1000 : (accumulatedTime / 1000);
                const penaltySeconds = penaltyMinutes * 60;
                sessionInterruptionTimestamps.push({ time: wallClockTimeAtInterruption, penalty: penaltySeconds });
                lastPenaltyResetTime = Date.now(); 
                
                accumulatedTime -= penaltySeconds * 1000;
                
                document.getElementById('logInterruptionModal').style.display = 'none'; 
                penaltyInput.value = '5';
                updateTimerDisplay(); 
            });
            document.getElementById('continueSessionBtn').addEventListener('click', () => {
                document.getElementById('extendedBreakModal').style.display = 'none';
                startTimer();
            });
            document.getElementById('endCurrentSessionBtn').addEventListener('click', () => {
                document.getElementById('extendedBreakModal').style.display = 'none';
                handleEndFocus(false);
            });

            // --- Reflection Modals ---
            document.getElementById('confirmReflectionBtn').addEventListener('click', () => {
                const { duration, interruptions, pauseEvents, type } = sessionDataForReflection;
                const quality = parseInt(document.querySelector('#reflectionModal .star-rating').dataset.rating) || 0;
                document.getElementById('reflectionModal').style.display = 'none';
                if (quality <= 3) { showReasonModal(duration, interruptions, pauseEvents, quality, type); }
                else { 
                    stopAndSaveSession({ duration, interruptions, pauseEvents, quality, reason: null, type });
                    launchSpotify();
                }
            });
            document.getElementById('saveReasonBtn').addEventListener('click', async () => {
                const reason = document.getElementById('newReasonInput').value.trim();
                const { duration, interruptions, pauseEvents, quality, type } = sessionDataForReflection;
                await stopAndSaveSession({ duration, interruptions, pauseEvents, quality, reason: reason || 'Unspecified', type });
                document.getElementById('reasonModal').style.display = 'none'; document.getElementById('improvementModal').style.display = 'flex';
            });
            document.getElementById('finishReflectionBtn').addEventListener('click', () => {
                document.getElementById('improvementModal').style.display = 'none';
                launchSpotify();
            });
            document.getElementById('adhocReflectBtn').addEventListener('click', () => {
                document.getElementById('adhocReflectionModal').style.display = 'none';
                showReflectionModal(sessionDataForReflection);
            });
            document.getElementById('adhocSkipBtn').addEventListener('click', async () => {
                document.getElementById('adhocReflectionModal').style.display = 'none';
                await stopAndSaveSession({ ...sessionDataForReflection, quality: null, reason: null });
                launchSpotify();
            });
            
            document.getElementById('saveRenameBtn').addEventListener('click', handleReasonSave);
            document.getElementById('confirmReassignBtn').addEventListener('click', handleReasonReassign);
            document.getElementById('deleteReasonBtn').addEventListener('click', handleReasonDelete);
            
            document.getElementById('settingsRitualText').addEventListener('input', () => debounceSaveSettings({ ritual: document.getElementById('settingsRitualText').value }, 'ritualSaveStatus'));
            document.getElementById('settingsSpotifyLink').addEventListener('input', () => debounceSaveSettings({ spotifyLink: document.getElementById('settingsSpotifyLink').value }, 'spotifySaveStatus'));
            document.getElementById('settingsMinSessionLength').addEventListener('input', () => debounceSaveSettings({ minSessionLength: parseInt(document.getElementById('settingsMinSessionLength').value) || null }, 'minSessionSaveStatus'));
            document.getElementById('settingsWeekStartsOn').addEventListener('change', () => {
                const weekStartsOn = parseInt(document.getElementById('settingsWeekStartsOn').value) || 0;
                saveSettings({ weekStartsOn });
                userSettings.weekStartsOn = weekStartsOn;
                renderCalendar();
                renderChart();
            });
            document.getElementById('addBreakActivityBtn').addEventListener('click', handleAddBreakActivity);
        }
        
        // --- AI Export Functions ---
        function downloadUserData() {
            const dataToExport = {
                focusedTimeData,
                goals,
                daysOff,
                lowQualityReasons,
                userSettings
            };
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(dataToExport, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "focus_data.json");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }

        function downloadAppCode() {
            // Download the current HTML content
            const htmlContent = document.documentElement.outerHTML;
            const dataStr = "data:text/html;charset=utf-8," + encodeURIComponent(htmlContent);
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "index.html");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }

        function generateAIPrompt() {
            // 1. NEW: Check if user has a custom saved prompt
            if (userSettings.customAiPrompt) {
                document.getElementById('aiPromptText').value = userSettings.customAiPrompt;
                return;
            }

            // 2. Standard Generation Logic (Existing code)
            const hasHabits = document.getElementById('aiHabitTrackerCheckbox').checked;
            let prompt = `I have attached my Focus Time Tracker data in JSON format and the application code for context.\n\nPlease analyze my focus data to provide insights on:\n1. Overall productivity trends (Focus Time vs. Goals).\n2. Interruption patterns and their impact on session quality.\n3. The consistency of my schedule.\n`;
            
            if (hasHabits) {
                prompt += `\nI also track my habits separately. Please suggest correlations I should look for between my focus metrics (like low quality sessions or high interruption rates) and potential habit triggers (e.g., sleep, exercise, phone usage). If I were to provide my habit data, how would you structure a correlation analysis?\n`;
            } else {
                prompt += `\nBased on the 'reasons' for low quality sessions, please suggest specific actionable improvements to my routine.\n`;
            }
            
            prompt += `\nFinally, please look at the code structure and suggest if there are any additional metrics I could easily track to improve these insights.`;
            
            document.getElementById('aiPromptText').value = prompt;
        }

        function handleEndFocus(completed = false) {
            if (!running && accumulatedTime < 1000) { 
                resetTimerState();
                return;
            }
            const wasRunning = running;
            if (wasRunning) {
                running = false;
                clearInterval(timerInterval);
                accumulatedTime += Date.now() - startTime;
            }

            if (!wasRunning && sessionPauseEvents.length > 0 && sessionPauseEvents[sessionPauseEvents.length - 1].end === null) {
                sessionPauseEvents[sessionPauseEvents.length - 1].end = (sessionAbsoluteStartTime ? (Date.now() - sessionAbsoluteStartTime) / 1000 : accumulatedTime / 1000);
            }
            const finalPauseEvents = sessionPauseEvents.filter(p => p.end !== null);
            const totalSessionMs = sessionAbsoluteStartTime ? (Date.now() - sessionAbsoluteStartTime) : accumulatedTime;
            
            const startTimeIso = sessionAbsoluteStartTime 
				? new Date(sessionAbsoluteStartTime).toISOString() 
				: new Date(Date.now() - accumulatedTime).toISOString(); // Fallback for edge cases

			sessionDataForReflection = { 
				duration: accumulatedTime, 
				totalSessionDuration: totalSessionMs, 
				interruptions: sessionInterruptionTimestamps, 
				pauseEvents: finalPauseEvents, 
				type: currentTimerMode,
				startTime: startTimeIso // <--- ADD THIS LINE
			};
            
            if (currentTimerMode === 'countdown') {
                if (completed) {
                    document.getElementById('medalModal').style.display = 'flex';
                    startOvertimeTimer();
                } else {
                    document.getElementById('earlyEndModal').style.display = 'flex';
                }
            } else if (currentTimerMode === 'stopwatch') {
                document.getElementById('adhocReflectionModal').style.display = 'flex';
            }
        }

        async function openGoalsModal() {
            const twoWeeksAgo = getLocalDateString(new Date(new Date().getTime() - 14*24*60*60*1000));
            let totalMins = 0, workDays = new Set(), totalInt = 0;
            let countdownSessionsOnWorkdays = 0;
            Object.entries(focusedTimeData).forEach(([d, data]) => {
                if (d >= twoWeeksAgo && !isDayOff(d)) {
                    workDays.add(d);
                    (data.sessions || []).forEach(s => {
                        totalMins += s.duration / 60; totalInt += (s.interruptions?.length || 0);
                        if(s.type === 'countdown') countdownSessionsOnWorkdays++;
                    });
                }
            });
            const avgDaily = workDays.size > 0 ? totalMins / workDays.size : 30;
            const avgSess = workDays.size > 0 ? countdownSessionsOnWorkdays / workDays.size : 2;
            const avgMinsPerInt = totalInt > 0 ? totalMins / totalInt : (avgDaily > 0 ? avgDaily : 30);
            document.getElementById('todayFocusGoal').value = Math.round(avgDaily * 1.05);
            document.getElementById('scheduledSessionsGoal').value = Math.round(avgSess > 0 ? avgSess : 2);
            document.getElementById('interruptionGoal').value = Math.round(avgMinsPerInt * 1.05);
            document.getElementById('goalsModal').style.display = 'flex';
        }

        function validateGoalInput(e) {
            const input = e.target;
            const errorEl = document.getElementById(`${input.id}Error`);
            const value = input.value;
            if (value === '' || (Number(value) >= 0 && !value.includes('.'))) {
                errorEl.textContent = '';
                return true;
            }
            errorEl.textContent = 'Please enter a whole positive number.';
            return false;
        }

        /**
         * Saves the goals for today to Firestore.
         */
        async function saveGoals() {
            const ids = ['todayFocusGoal', 'scheduledSessionsGoal', 'interruptionGoal'];
            let isValid = true;
            ids.forEach(id => {
                if (!validateGoalInput({target: document.getElementById(id)})) {
                    isValid = false;
                }
            });
            if (!isValid) return;

            // [FIX] Use getLocalDateString to avoid timezone issues
            const today = getLocalDateString(new Date());
            const goalsData = {
                dailyGoal: parseInt(document.getElementById('todayFocusGoal').value) || 0,
                scheduledSessionsGoal: parseInt(document.getElementById('scheduledSessionsGoal').value) || 0,
                interruptionGoal: parseInt(document.getElementById('interruptionGoal').value) || 0
            };
            try {
                await setDoc(doc(db, `artifacts/${APP_ID_FOR_FIRESTORE}/users/${userId}/goals`, today), goalsData);
                document.getElementById('goalsModal').style.display = 'none';
            } catch (e) { console.error("Error saving goals:", e);
            }
        }
        
        /**
         * Disables the "Set Goals" button if goals are already set for today.
         */
        function checkAndManageGoalsUI() {
            // [FIX] Use getLocalDateString to avoid timezone issues
            const todayStr = getLocalDateString(new Date());
            document.getElementById('openGoalsModalBtn').disabled = !!goals[todayStr];
        }

        /**
         * Generates a suggested star rating based on interruption count.
         */
        function getRatingSuggestionByInterruptionCount(interruptions, duration) {
            const interruptionCount = interruptions.length;
            const totalPenaltyMinutes = interruptions.reduce((sum, i) => sum + (i.penalty || 0), 0) / 60;

            // Check recent history for similar sessions
            const allRatedSessions = Object.values(focusedTimeData)
                .flatMap(d => d.sessions || [])
                .filter(s => s.quality != null)
                .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            
            const recent50 = allRatedSessions.slice(0, 50);

            if (recent50.length > 2) {
                const similarSessions = recent50.filter(s => (s.interruptions?.length || 0) === interruptionCount);
                if (similarSessions.length > 2) {
                    const totalQuality = similarSessions.reduce((sum, s) => sum + s.quality, 0);
                    return Math.round(totalQuality / similarSessions.length);
                }
            }

            // Fallback to formula
            const durationMinutes = duration / 1000 / 60;
            if (durationMinutes <= 0) {
                return Math.max(1, 5 - interruptionCount);
            }
            
            const disruptionScore = (interruptionCount * 1) + (totalPenaltyMinutes * 0.2);
            const normalizedDisruption = disruptionScore / (durationMinutes / 30);
            
            return Math.max(1, Math.round(5 - normalizedDisruption));
        }

        /**
         * Generates a suggested star rating based on historical Mins/Interruption.
         */
        function getHistoricalRatingSuggestion(duration, interruptions) {
            const interruptionCount = interruptions.length;
            if (duration <= 0) {
                return getRatingSuggestionByInterruptionCount(interruptions, duration);
            }
            
            const currentMpi = interruptionCount > 0 ? (duration / 1000 / 60) / interruptionCount : (duration / 1000 / 60);
            const allRatedSessions = Object.values(focusedTimeData)
                .flatMap(d => d.sessions || [])
                .filter(s => s.quality != null && s.duration > 0)
                .map(s => {
                    const ints = s.interruptions?.length || 0;
                    const mpi = ints > 0 ? (s.duration / 60) / ints : s.duration / 60; // in minutes
                    return { ...s, mpi };
                })
                .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            
            if (allRatedSessions.length < 5) {
                return getRatingSuggestionByInterruptionCount(interruptions, duration);
            }
            
            // Find sessions with similar MPI
            const similarSessions = allRatedSessions.filter(s => {
                if (currentMpi === 0) return s.mpi === 0;
                const similarity = Math.abs(s.mpi - currentMpi) / currentMpi;
                return similarity <= 0.25; // Within 25%
            });

            if (similarSessions.length > 2) {
                const totalQuality = similarSessions.reduce((sum, s) => sum + s.quality, 0);
                return Math.round(totalQuality / similarSessions.length);
            }
            
            // Fallback to simple interruption count logic
            return getRatingSuggestionByInterruptionCount(interruptions, duration);
        }

        /**
         * Shows the "Reason for Low Quality" modal.
         */
        function showReasonModal(duration, interruptions, pauseEvents, quality, type) {
            sessionDataForReflection = { duration, interruptions, pauseEvents, quality, type };
            const container = document.getElementById('pastReasonsContainer'); container.innerHTML = '';
            // Populate with existing reasons
            lowQualityReasons.forEach(r => {
                const b = document.createElement('button'); b.className = 'btn text-sm bg-gray-200 hover:bg-gray-300 text-gray-700 p-2';
                b.textContent = r; b.onclick = () => document.getElementById('newReasonInput').value = r; container.appendChild(b)
            });
            document.getElementById('reasonModal').style.display = 'flex';
        }

        /**
         * Sets up the date ranges for the comparison chart.
         */
        function setupComparisonControls() {
            document.getElementById('compareToggle').checked = false;
            document.getElementById('period2Container').classList.add('hidden');
            
            // Default "Period 1" to the last 20 work days
            let workDays = []; 
            let dayIterator = new Date(); 
            dayIterator.setHours(12,0,0,0);
            for (let i = 0; workDays.length < 20 && i < 365; i++) {
                const cur = new Date(dayIterator);
                cur.setDate(dayIterator.getDate() - i); 
                // [FIX] Use getLocalDateString to avoid timezone issues
                const str = getLocalDateString(cur);
                if (!isDayOff(str)) { 
                    workDays.unshift(cur);
                }
            }
            if (workDays.length > 0) {
                // [FIX] Use getLocalDateString to avoid timezone issues
                const endDate = getLocalDateString(workDays[workDays.length - 1]);
                const startDate = getLocalDateString(workDays[0]);
                document.getElementById('range1Start').value = startDate;
                document.getElementById('range1End').value = endDate;
            } else {
                 // Fallback if no work days found
                 const today = new Date();
                 const lastWeek = new Date();
                 lastWeek.setDate(today.getDate() - 7);
                 // [FIX] Use getLocalDateString to avoid timezone issues
                 document.getElementById('range1Start').value = getLocalDateString(lastWeek);
                 document.getElementById('range1End').value = getLocalDateString(today);
            }

            renderChart();
        }

        /**
         * Sets up the date ranges for the reason chart.
         */
        function setupReasonChartControls() {
            // Default to the last 30 work days
            let workDays = []; 
            let dayIterator = new Date(); 
            dayIterator.setHours(12,0,0,0);
            for (let i = 0; workDays.length < 30 && i < 365; i++) { // Look for 30 work days
                const cur = new Date(dayIterator);
                cur.setDate(dayIterator.getDate() - i); 
                // [FIX] Use getLocalDateString to avoid timezone issues
                const str = getLocalDateString(cur);
                if (!isDayOff(str)) { 
                    workDays.unshift(cur);
                }
            }
            if (workDays.length > 0) {
                // [FIX] Use getLocalDateString to avoid timezone issues
                const endDate = getLocalDateString(workDays[workDays.length - 1]);
                const startDate = getLocalDateString(workDays[0]);
                document.getElementById('reasonRangeStart').value = startDate;
                document.getElementById('reasonRangeEnd').value = endDate;
            } else {
                 // Fallback if no work days found
                 const today = new Date();
                 const lastMonth = new Date();
                 lastMonth.setDate(today.getDate() - 30);
                 // [FIX] Use getLocalDateString to avoid timezone issues
                 document.getElementById('reasonRangeStart').value = getLocalDateString(lastMonth);
                 document.getElementById('reasonRangeEnd').value = getLocalDateString(today);
            }

            renderChart(); // Render chart with new default dates
        }

        /**
         * Opens the modal to manage (rename, re-assign, delete) a reason.
         * @param {string} reason - The reason to manage.
         */
        function openManageReasonModal(reason) {
            const modal = document.getElementById('manageReasonModal');
            document.getElementById('originalReasonInput').value = reason;
            document.getElementById('renameReasonInput').value = reason;
            const select = document.getElementById('reassignReasonSelect'); select.innerHTML = '';
            // Populate dropdown with *other* reasons
            lowQualityReasons.filter(r => r !== reason).forEach(r => { const option = document.createElement('option'); option.value = r; option.textContent = r; select.appendChild(option); });
            select.disabled = select.options.length === 0;
            modal.style.display = 'flex';
        }

        /**
         * Renames a reason across all sessions.
         */
        async function handleReasonSave() {
            const originalReason = document.getElementById('originalReasonInput').value, newReason = document.getElementById('renameReasonInput').value.trim();
            if (!newReason || newReason === originalReason) return;
            if (lowQualityReasons.includes(newReason)) { showMessage(`Reason "${newReason}" already exists.`); return;
            }
            const batch = writeBatch(db);
            // Update all sessions
            for (const date in focusedTimeData) {
                const sessions = focusedTimeData[date].sessions || [];
                if (sessions.some(s => s.reason === originalReason)) {
                    const updatedSessions = sessions.map(s => s.reason === originalReason ? { ...s, reason: newReason } : s);
                    const docRef = doc(db, `artifacts/${APP_ID_FOR_FIRESTORE}/users/${userId}/focusSessions`, date); batch.update(docRef, { sessions: updatedSessions });
                }
            }
            // Update the master list of reasons
            const reasonsDocRef = doc(db, `artifacts/${APP_ID_FOR_FIRESTORE}/users/${userId}/reflectionData/reasons`);
            batch.update(reasonsDocRef, { reasons: arrayRemove(originalReason) }); batch.update(reasonsDocRef, { reasons: arrayUnion(newReason) });
            await batch.commit(); showMessage(`Reason renamed to "${newReason}"`); document.getElementById('manageReasonModal').style.display = 'none';
        }
        
        /**
         * Re-assigns all sessions from one reason to another.
         */
        async function handleReasonReassign() {
            const originalReason = document.getElementById('originalReasonInput').value, targetReason = document.getElementById('reassignReasonSelect').value;
            if (!targetReason) return;
            const batch = writeBatch(db);
            // Update all sessions
            for (const date in focusedTimeData) {
                const sessions = focusedTimeData[date].sessions || [];
                 if (sessions.some(s => s.reason === originalReason)) {
                    const updatedSessions = sessions.map(s => s.reason === originalReason ? { ...s, reason: targetReason } : s);
                    const docRef = doc(db, `artifacts/${APP_ID_FOR_FIRESTORE}/users/${userId}/focusSessions`, date); batch.update(docRef, { sessions: updatedSessions });
                }
            }
            // Remove the old reason from the master list
            const reasonsDocRef = doc(db, `artifacts/${APP_ID_FOR_FIRESTORE}/users/${userId}/reflectionData/reasons`);
            batch.update(reasonsDocRef, { reasons: arrayRemove(originalReason) });
            await batch.commit(); showMessage(`Reason "${originalReason}" was merged into "${targetReason}".`);
            document.getElementById('manageReasonModal').style.display = 'none';
        }

        /**
         * Deletes a reason entirely from all sessions.
         */
        async function handleReasonDelete() {
             const reasonToDelete = document.getElementById('originalReasonInput').value;
             if (!await showConfirm(`Delete reason "${reasonToDelete}" from all entries? This cannot be undone.`)) return;
             const batch = writeBatch(db);
             // Update all sessions, setting reason to null
             for (const date in focusedTimeData) {
                const sessions = focusedTimeData[date].sessions || [];
                 if (sessions.some(s => s.reason === reasonToDelete)) {
                    const updatedSessions = sessions.map(s => s.reason === reasonToDelete ? { ...s, reason: null } : s);
                    const docRef = doc(db, `artifacts/${APP_ID_FOR_FIRESTORE}/users/${userId}/focusSessions`, date); batch.update(docRef, { sessions: updatedSessions });
                }
            }
            // Remove from master list
            const reasonsDocRef = doc(db, `artifacts/${APP_ID_FOR_FIRESTORE}/users/${userId}/reflectionData/reasons`);
            batch.update(reasonsDocRef, { reasons: arrayRemove(reasonToDelete) });
            await batch.commit(); showMessage(`Reason "${reasonToDelete}" was deleted.`); document.getElementById('manageReasonModal').style.display = 'none';
        }

        /**
         * Schedules a 15-minute "Still focusing?" notification.
         */
        function scheduleNextNotification() {
            if (notificationTimeoutId) clearTimeout(notificationTimeoutId);
            if (!notificationsEnabled || !running) return;
            notificationTimeoutId = setTimeout(() => { if (Notification.permission === 'granted') new Notification('Still focusing?'); scheduleNextNotification() }, 15 * 60 * 1000);
        }

        /**
         * Starts the break timer display.
         */
        function startBreakTimer() {
            stopBreakTimer();
            if (currentTimerMode === 'countdown') {
                const suggestionEl = document.getElementById('breakActivitySuggestion');
                const activities = userSettings.breakActivities || [];
                if (activities.length > 0) {
                    suggestionEl.textContent = `Suggested Activities: ${activities.join(', ')}`;
                    suggestionEl.classList.remove('hidden');
                }
            }
            document.getElementById('breakTimerDisplay').classList.remove('hidden');
            breakStartTime = Date.now();
            breakTimerInterval = setInterval(() => {
                const elapsedSeconds = (Date.now() - breakStartTime) / 1000;
                const minutes = String(Math.floor(elapsedSeconds / 60)).padStart(2, '0');
                const seconds = String(Math.floor(elapsedSeconds % 60)).padStart(2, '0');
                document.getElementById('breakTimerDisplay').textContent = `Break: ${minutes}:${seconds}`;
             }, 1000);
        }

        /**
         * Stops the break timer display.
         */
        function stopBreakTimer() {
            clearInterval(breakTimerInterval);
            document.getElementById('breakTimerDisplay').classList.add('hidden');
            document.getElementById('breakActivitySuggestion').classList.add('hidden');
        }

        /**
         * Starts the overtime timer in the "Medal" modal.
         */
        function startOvertimeTimer() {
            overtimeStartTime = Date.now();
            overtimeInterval = setInterval(() => {
                const elapsedSeconds = (Date.now() - overtimeStartTime) / 1000;
                document.getElementById('overtimeDisplay').textContent = formatTimer(elapsedSeconds);
            }, 1000);
        }

        /**
         * Opens the settings modal and populates it with user settings.
         */
        function openSettingsModal() {
            document.getElementById('settingsRitualText').value = userSettings.ritual || '';
            document.getElementById('settingsSpotifyLink').value = userSettings.spotifyLink || '';
            document.getElementById('settingsMinSessionLength').value = userSettings.minSessionLength || '';
            // [NEW] Set the value for the weekStartsOn dropdown
            document.getElementById('settingsWeekStartsOn').value = userSettings.weekStartsOn || 0;
            renderBreakActivitiesList();
            document.getElementById('settingsModal').style.display = 'flex';
        }
        
        /**
         * Debounces saving settings to Firestore.
         * @param {object} newSettings - The settings object to save.
         * @param {string} statusElId - The ID of the element to show save status.
         */
        function debounceSaveSettings(newSettings, statusElId) {
            const status = document.getElementById(statusElId);
            status.textContent = 'Typing...';
            clearTimeout(settingsSaveTimers[statusElId]);
            settingsSaveTimers[statusElId] = setTimeout(() => {
                saveSettings(newSettings);
                status.textContent = 'Saved!';
                setTimeout(() => status.textContent = '', 2000);
            }, 1000);
        }

        /**
         * Saves settings to Firestore.
         * @param {object} newSettings - The settings object to save.
         */
        async function saveSettings(newSettings) {
            const settingsDocRef = doc(db, `artifacts/${APP_ID_FOR_FIRESTORE}/users/${userId}/settings/main`);
            await setDoc(settingsDocRef, newSettings, { merge: true });
        }

        /**
         * Renders the list of break activities in the settings modal.
         */
        function renderBreakActivitiesList() {
            const list = document.getElementById('breakActivitiesList');
            list.innerHTML = '';
            (userSettings.breakActivities || []).forEach(activity => {
                const li = document.createElement('li'); li.className = 'flex justify-between items-center p-2 bg-gray-100 rounded';
                li.textContent = activity;
                const deleteBtn = document.createElement('button'); deleteBtn.className = 'text-red-500 hover:text-red-700 font-bold px-2';
                deleteBtn.innerHTML = '√ó';
                deleteBtn.onclick = () => handleDeleteBreakActivity(activity);
                li.appendChild(deleteBtn);
                list.appendChild(li);
            });
        }
        
        /**
         * Adds a new break activity to user settings.
         */
        async function handleAddBreakActivity() {
            const input = document.getElementById('newBreakActivityInput');
            const newActivity = input.value.trim();
            if (newActivity && !(userSettings.breakActivities || []).includes(newActivity)) {
                await saveSettings({ breakActivities: arrayUnion(newActivity) });
                input.value = '';
                const status = document.getElementById('breakActivitySaveStatus');
                status.textContent = 'Activity added!';
                setTimeout(() => status.textContent = '', 2000);
            }
        }

        /**
         * Deletes a break activity from user settings.
         * @param {string} activity - The activity to remove.
         */
        async function handleDeleteBreakActivity(activity) { 
            await saveSettings({ breakActivities: arrayRemove(activity) });
            const status = document.getElementById('breakActivitySaveStatus');
            status.textContent = 'Activity removed!';
            setTimeout(() => status.textContent = '', 2000);
        }

        /**
         * Sets up the interactive star rating component.
         * @param {HTMLElement} starContainer - The container element for the stars.
         */
        function setupStarRating(starContainer) {
            const stars = starContainer.querySelectorAll('.fa-star');
            starContainer.addEventListener('mouseleave', () => stars.forEach(s => s.classList.remove('hover')));
            stars.forEach(star => {
                star.addEventListener('mouseenter', e => {
                    const rating = e.target.dataset.value;
                    stars.forEach(s => s.classList.toggle('hover', s.dataset.value <= rating));
                });
                star.addEventListener('click', e => {
                    const rating = e.target.dataset.value;
                    starContainer.dataset.rating = rating;
                    stars.forEach(s => s.classList.toggle('selected', s.dataset.value <= rating));
                });
            });
        }

        /**
         * Attempts to launch the Spotify app, with a fallback to the web player.
         */
        function launchSpotify() {
            if (!focusMusicEnabled) return;
            let spotifyUrl = userSettings.spotifyLink || 'https://open.spotify.com/artist/4GLYyR12mcN6csCeLaqSKo1';

            if (spotifyUrl) {
                // Clean up the URL
                spotifyUrl = spotifyUrl.split('?')[0];
                spotifyUrl = spotifyUrl.replace(/\/intl-[a-z]{2}/, '');
            }

            const appUri = spotifyUrl.replace(/https?:\/\/open\.spotify\.com\//, 'spotify:');
            
            // Set a fallback timer
            const fallbackTimeout = setTimeout(() => {
                // If this runs, the app didn't open.
                window.removeEventListener('blur', blurHandler);
                window.removeEventListener('visibilitychange', visibilityChangeHandler);
                window.open(spotifyUrl, '_blank');
            }, 3000); 

            // Handler to clear timeout if app switch is successful
            const blurHandler = () => {
                clearTimeout(fallbackTimeout);
                window.removeEventListener('blur', blurHandler);
                window.removeEventListener('visibilitychange', visibilityChangeHandler);
            };
            
            const visibilityChangeHandler = () => {
                if (document.visibilityState === 'hidden') {
                    clearTimeout(fallbackTimeout);
                    window.removeEventListener('blur', blurHandler);
                    window.removeEventListener('visibilitychange', visibilityChangeHandler);
                }
            };

            window.addEventListener('blur', blurHandler);
            window.addEventListener('visibilitychange', visibilityChangeHandler);
            
            // Attempt to open app URI via iframe
            const iframe = document.createElement('iframe');
            iframe.style.display = 'none';
            iframe.src = appUri;
            document.body.appendChild(iframe);

            // Clean up the iframe and listeners
            setTimeout(() => {
                if (document.body.contains(iframe)) {
                    document.body.removeChild(iframe);
                }
            }, 500);
            
            setTimeout(() => {
                 window.removeEventListener('blur', blurHandler);
                 window.removeEventListener('visibilitychange', visibilityChangeHandler);
            }, 3500);
        }

        // --- Utility Modals ---
        /**
         * Shows a simple message modal.
         * @param {string} msg - The message to display.
         */
        function showMessage(msg) { document.getElementById('modalMessage').textContent = msg; document.getElementById('messageModal').style.display = 'flex'; }
        
        /**
         * Shows a confirmation modal.
         * @param {string} msg - The confirmation message.
         * @returns {Promise<boolean>} A promise that resolves to true (Confirm) or false (Cancel).
         */
        function showConfirm(msg) {
            return new Promise(resolve => {
                const confirmModal = document.getElementById('confirmModal');
                document.getElementById('confirmMessage').textContent = msg;
                confirmModal.style.display = 'flex';
                document.getElementById('confirmOkBtn').onclick = () => { confirmModal.style.display = 'none'; resolve(true); };
                document.getElementById('confirmCancelBtn').onclick = () => { confirmModal.style.display = 'none'; resolve(false); };
            });
        }
    </script>
</body>
</html>
