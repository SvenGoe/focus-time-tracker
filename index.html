<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Focus Time Tracker</title>
    <!-- Favicon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>⏲️</text></svg>">
    
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js CDN for charts -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap');
        body { font-family: 'Inter', sans-serif; background-color: #f3f4f6; }
        .container { max-width: 1200px; margin: 2rem auto; padding: 2rem; background-color: #ffffff; border-radius: 0.75rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
        .btn { padding: 0.75rem 1.5rem; border-radius: 0.5rem; font-weight: 600; transition: all 0.2s ease-in-out; border: none; cursor: pointer; }
        .btn:disabled { background-color: #d1d5db; color: #6b7280; cursor: not-allowed; }
        .btn-green { background-color: #10B981; color: white; }
        .btn-green:hover:not(:disabled) { background-color: #059669; }
        .btn-red { background-color: #EF4444; color: white; }
        .btn-red:hover:not(:disabled) { background-color: #DC2626; }
        .btn-blue { background-color: #3B82F6; color: white; }
        .btn-blue:hover:not(:disabled) { background-color: #2563EB; }
        .btn-orange { background-color: #F97316; color: white; }
        .btn-orange:hover:not(:disabled) { background-color: #EA580C; }
        .btn-yellow { background-color: #F59E0B; color: white; }
        .btn-yellow:hover:not(:disabled) { background-color: #D97706; }
        .view-btn { padding: 0.5rem 1rem; border-radius: 0.5rem; font-size: 0.875rem; font-weight: 500; background-color: #E5E7EB; color: #374151; transition: background-color 0.2s ease-in-out; }
        .view-btn.active { background-color: #3B82F6; color: white; }
        .view-btn:hover:not(.active) { background-color: #D1D5DB; }
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5); align-items: center; justify-content: center; }
        .modal-content { background-color: #fefefe; margin: auto; padding: 2rem; border-radius: 0.75rem; width: 90%; max-width: 450px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15); }
        .close-button { color: #aaa; float: right; font-size: 28px; font-weight: bold; line-height: 1; }
        .close-button:hover, .close-button:focus { color: black; text-decoration: none; cursor: pointer; }
        .log-entry-item { background-color: #f8f8f8; border: 1px solid #e5e7eb; border-radius: 0.5rem; padding: 0.75rem; margin-bottom: 0.5rem; display: flex; flex-direction: column; gap: 0.5rem; }
        @media (min-width: 640px) { .log-entry-item { flex-direction: row; justify-content: space-between; align-items: center; } }
        .toggle-checkbox { position: absolute; display: block; width: 1.5rem; height: 1.5rem; border-radius: 9999px; background-color: white; border: 4px solid transparent; -webkit-appearance: none; -moz-appearance: none; appearance: none; cursor: pointer; transition: transform 0.2s ease-in-out, border-color 0.2s ease-in-out; left: 0; }
        .toggle-checkbox:checked { border-color: #10B981; transform: translateX(1rem); }
        .toggle-label { display: block; overflow: hidden; height: 1.5rem; border-radius: 9999px; background-color: #D1D5DB; cursor: pointer; transition: background-color 0.2s ease-in-out; }
        .toggle-checkbox:checked + .toggle-label { background-color: #10B981; }
        .calendar-day { transition: all 0.2s ease-in-out; border: 2px solid transparent; }
        .calendar-day:hover { transform: scale(1.05); box-shadow: 0 0 10px rgba(59, 130, 246, 0.5); }
        .day-off-explicit { background-color: #fca5a5 !important; color: #b91c1c; font-weight: bold; border-color: #ef4444; }
        .today { border: 2px solid #3B82F6; }
        .star-rating .fa-star { color: #e5e7eb; cursor: pointer; transition: color 0.2s; font-size: 1.5rem; }
        #reflectionModal .star-rating .fa-star, #editLogModal .star-rating .fa-star { font-size: 2rem; }
        .star-rating .fa-star.hover, .star-rating .fa-star.selected { color: #f59e0b; }
        .log-star { font-size: 0.8rem; color: #f59e0b;}
        .timeline-container { position: relative; padding-bottom: 20px; }
        .timeline { position: relative; width: 100%; height: 8px; background-color: #e5e7eb; border-radius: 4px; margin-top: 0.5rem; }
        .timeline-segment { position: absolute; top: 0; height: 100%; }
        .timeline-focus { background-color: #A7F3D0; }
        .timeline-break { background-color: rgba(16, 185, 129, 0.4); border-left: 2px solid #059669; border-right: 2px solid #059669; }
        .timeline-penalty { background-color: rgba(239, 68, 68, 0.6); }
        .timeline-dot { position: absolute; top: 50%; width: 16px; height: 16px; background-color: #ef4444; border-radius: 50%; transform: translateY(-50%); border: 2px solid white; box-shadow: 0 0 5px rgba(0,0,0,0.2); z-index: 3; }
        .timeline-marker { position: absolute; top: 16px; transform: translateX(-50%); font-size: 10px; color: #6b7280; }
        .info-tooltip-container { position: relative; display: inline-block; }
        .info-tooltip-text { visibility: hidden; width: 220px; background-color: #555; color: #fff; text-align: center; border-radius: 6px; padding: 5px 10px; position: absolute; z-index: 1; bottom: 125%; left: 50%; margin-left: -110px; opacity: 0; transition: opacity 0.3s; font-size: 0.75rem; line-height: 1.25rem; }
        .info-tooltip-container:hover .info-tooltip-text { visibility: visible; opacity: 1; }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">
    <div class="container bg-white rounded-xl shadow-lg p-8 w-full">
        <!-- Header -->
        <div class="w-full flex justify-between items-center mb-6">
            <div class="flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-clock text-blue-600 mr-3"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
                <h1 class="text-2xl md:text-4xl font-bold text-gray-800">Focus Time Tracker</h1>
            </div>
            <div id="authContainer" class="flex items-center space-x-3"></div>
        </div>
        
        <!-- Loading Message -->
        <div id="loadingMessage" class="text-xl text-gray-700 text-center py-10">Initializing...</div>
        
        <!-- Main App Section -->
        <div id="appSection" class="w-full hidden">
            <!-- Timer Controls -->
            <div class="bg-white rounded-lg shadow-md p-6 text-center border border-gray-200 mb-8">
                <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                    <div class="md:col-span-2">
                        <!-- Timer Mode Buttons -->
                        <div class="flex justify-center space-x-4 mb-4">
                            <button id="stopwatchModeBtn" class="timer-mode-btn view-btn active">Ad-hoc Focus</button>
                            <button id="countdownModeBtn" class="timer-mode-btn view-btn">Focus Session</button>
                        </div>
                        <!-- Timer Display -->
                        <div id="timerDisplayContainer" class="text-center">
                            <div id="timerDisplay" class="flex flex-col justify-center text-6xl font-extrabold text-blue-600 p-4 bg-blue-50 rounded-lg h-36">
                                <p id="timerModeDescription" class="text-gray-500 text-xs font-semibold uppercase tracking-wider mb-3">Stopwatch</p>
                                <span id="timeValue">00:00:00</span>
                            </div>
                             <div id="nextBreakCountdown" class="text-md text-gray-500 hidden h-6 mt-2"></div>
                             <div id="breakTimerDisplay" class="text-lg font-bold text-gray-600 hidden h-6 mt-2"></div>
                             <div id="breakActivitySuggestion" class="text-md text-blue-600 hidden h-6 mt-2"></div>
                        </div>
                        <!-- Timer Action Buttons -->
                        <div class="flex justify-center items-center space-x-4 mt-4">
                            <button id="togglePauseBtn" class="btn btn-green shadow-md">Start Focusing</button>
                            <button id="endFocusBtn" class="btn btn-red shadow-md">End Focusing</button>
                        </div>
                    </div>
                    <!-- Interruptions and Toggles -->
                    <div class="flex flex-col justify-between space-y-6">
                        <div class="p-4 bg-yellow-50 rounded-lg shadow-inner h-full flex flex-col justify-center items-center">
                            <h3 class="text-lg font-semibold text-yellow-800 mb-2">Interruptions</h3>
                            <p class="text-3xl font-bold text-yellow-900 mb-3" id="sessionInterruptionsDisplay">0</p>
                            <button id="logInterruptionBtn" class="btn btn-yellow w-full" disabled>Log Interruption</button>
                        </div>
                        <div class="flex justify-around items-center pt-4 border-t">
                            <div class="flex items-center space-x-3">
                                <label for="notificationToggle" class="text-gray-700 font-medium">Reminders</label>
                                <div class="relative inline-block w-10 align-middle select-none">
                                    <input type="checkbox" name="notificationToggle" id="notificationToggle" class="toggle-checkbox"/>
                                    <label for="notificationToggle" class="toggle-label"></label>
                                </div>
                            </div>
                            <div class="flex items-center space-x-3">
                                <label for="focusMusicToggle" class="text-gray-700 font-medium">Music</label>
                                <div class="relative inline-block w-10 align-middle select-none">
                                    <input type="checkbox" name="focusMusicToggle" id="focusMusicToggle" class="toggle-checkbox"/>
                                    <label for="focusMusicToggle" class="toggle-label"></label>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- KPI Dashboard -->
            <div class="w-full p-6 bg-purple-50 rounded-lg shadow-inner mb-8">
                 <div class="grid grid-cols-1 sm:grid-cols-3 items-center mb-6 gap-4">
                    <div class="sm:col-start-2 text-center">
                         <h2 id="kpiDashboardTitle" class="text-2xl font-semibold text-purple-700">KPI Dashboard</h2>
                    </div>
                    <div class="sm:col-start-3 flex sm:justify-end">
                        <button id="openGoalsModalBtn" class="btn btn-blue w-full sm:w-auto">Set Goals</button>
                    </div>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
                    <div class="bg-white p-4 rounded-lg shadow-sm text-center"><h3 class="font-semibold text-gray-600">Focus Time</h3><p id="todayProgressText" class="text-2xl font-bold text-blue-600 my-2">0 / 0 min</p><div class="w-full bg-gray-200 rounded-full h-2.5"><div id="todayProgressBar" class="bg-blue-600 h-2.5 rounded-full" style="width: 0%; transition: width 0.5s;"></div></div></div>
                    <div class="bg-white p-4 rounded-lg shadow-sm text-center"><h3 class="font-semibold text-gray-600">Focus Sessions</h3><p id="sessionsProgressText" class="text-2xl font-bold text-green-600 my-2">0 / 0</p><div class="w-full bg-gray-200 rounded-full h-2.5"><div id="sessionsProgressBar" class="bg-green-500 h-2.5 rounded-full" style="width: 0%; transition: width 0.5s;"></div></div></div>
                    <div class="bg-white p-4 rounded-lg shadow-sm text-center"><h3 class="font-semibold text-gray-600">Mins/Interruption</h3><div id="minsPerInterruptionContainer" class="flex items-center justify-center my-2"><p id="minsPerInterruptionText" class="text-2xl font-bold text-red-500">0 min</p></div>
                        <div class="text-xs text-gray-500 flex flex-col sm:flex-row sm:justify-center sm:items-center">
                            <span class="mr-1">Max Uninterrupted Focus:</span>
                            <span id="maxFocusText">0 min</span>
                        </div>
                    </div>
                    <div class="bg-white p-4 rounded-lg shadow-sm text-center"><h3 class="font-semibold text-gray-600">Focus Streak</h3><div class="flex items-center justify-center my-2"><div class="text-4xl mr-2">🔥</div><p id="streakText" class="text-2xl font-bold text-orange-500">0 Days</p></div><p class="text-xs text-gray-500">Consecutive days meeting your goal</p></div>
                </div>
            </div>

            <!-- Stats Chart -->
            <div class="w-full p-6 bg-yellow-50 rounded-lg shadow-inner mb-8">
                <h2 class="text-2xl font-semibold text-yellow-700 mb-4 text-center flex justify-center items-center gap-2">
                    <span>Focus Time Stats</span>
                    <span id="chartInfoIconContainer"></span>
                </h2>
                <!-- Chart Controls -->
                <div class="flex flex-col sm:flex-row justify-center items-center gap-4 mb-6">
                    <select id="chartTypeSelect" class="p-2 rounded-md border-gray-300 shadow-sm">
                        <optgroup label="Focus Time">
                            <option value="avgDailyFocusTime">Avg Daily Focus Time</option>
                            <option value="totalFocusTime">Total Focus Time</option>
                        </optgroup>
                        <optgroup label="Focus Sessions">
                             <option value="completedSessions">Completed Sessions vs. Goal</option>
                        </optgroup>
                        <optgroup label="Focus Quality">
                             <option value="avgQuality">Avg Focus Quality Rating</option>
                             <option value="reasonBubbleChart">Reasons for Low Quality</option>
                        </optgroup>
                        <optgroup label="Interruptions">
                            <option value="minsPerInterruption">Avg Mins per Interruption</option>
                            <option value="interruptionLikelihood">Interruption Rate</option>
                        </optgroup>
                    </select>
                    <div id="chartViewControls" class="flex space-x-2">
                        <button id="viewDay" class="view-btn active">Day</button>
                        <button id="viewWeek" class="view-btn">Week</button>
                        <button id="viewMonth" class="view-btn">Month</button>
                        <button id="viewYear" class="view-btn">Year</button>
                    </div>
                     <div id="comparisonControls" class="hidden flex-wrap items-center justify-center gap-4">
                        <div class="flex items-center gap-2 p-2 bg-gray-100 rounded-lg">
                            <label for="range1Start" class="font-semibold text-sm text-gray-600">Period 1:</label>
                            <input type="date" id="range1Start" class="p-1 border rounded-md text-sm">
                            <span class="text-gray-500">-</span>
                            <input type="date" id="range1End" class="p-1 border rounded-md text-sm">
                        </div>
                        <div class="flex items-center gap-2">
                            <input type="checkbox" id="compareToggle" class="h-4 w-4 rounded border-gray-300">
                            <label for="compareToggle" class="text-sm font-medium text-gray-700">Compare</label>
                        </div>
                        <div id="period2Container" class="hidden items-center gap-2 p-2 bg-gray-100 rounded-lg">
                            <label for="range2Start" class="font-semibold text-sm text-gray-600">Period 2:</label>
                            <input type="date" id="range2Start" class="p-1 border rounded-md text-sm">
                            <span class="text-gray-500">-</span>
                            <input type="date" id="range2End" class="p-1 border rounded-md text-sm">
                        </div>
                    </div>
                </div>
                <!-- Chart Canvas -->
                <div class="relative h-80 w-full"><canvas id="timeChart"></canvas></div>
            </div>

            <!-- Log and Calendar Section -->
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-8 mt-10">
                <!-- Log -->
                <div class="lg:col-span-2 w-full p-6 bg-blue-50 rounded-lg shadow-inner">
                    <!-- Manual Entry -->
                    <div class="mb-6 p-4 border border-blue-200 rounded-lg">
                        <h3 class="text-xl font-medium text-blue-600 mb-3">Add New Focus Entry</h3>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div><label for="newEntryDate" class="block text-sm font-medium text-gray-700">Date</label><input type="date" id="newEntryDate" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2"></div>
                             <div class="flex space-x-2">
                                <div class="flex-1"><label for="newEntryHours" class="block text-sm font-medium text-gray-700">Hours</label><input type="number" id="newEntryHours" min="0" value="0" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2"></div>
                                <div class="flex-1"><label for="newEntryMinutes" class="block text-sm font-medium text-gray-700">Minutes</label><input type="number" id="newEntryMinutes" min="0" max="59" value="0" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2"></div>
                            </div>
                            <div><label for="newEntryInterruptions" class="block text-sm font-medium text-gray-700">Interruptions (optional)</label><input type="number" id="newEntryInterruptions" min="0" placeholder="0" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2"></div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Quality (optional)</label>
                                <div class="star-rating flex items-center mt-2" data-rating="0" id="newEntryStarRating">
                                    <i class="fa-solid fa-star" data-value="1"></i><i class="fa-solid fa-star" data-value="2"></i><i class="fa-solid fa-star" data-value="3"></i><i class="fa-solid fa-star" data-value="4"></i><i class="fa-solid fa-star" data-value="5"></i>
                                </div>
                            </div>
                        </div>
                        <button id="addEntryBtn" class="btn btn-blue mt-4 w-full">Add Entry</button>
                    </div>
                    <!-- Log Entries -->
                    <h2 class="text-2xl font-semibold text-blue-700 mb-4 text-center">Focus Time Log</h2>
                    <div id="logEntries" class="space-y-3"><p class="text-center text-gray-500">No entries yet.</p></div>
                    <button id="showMoreLogBtn" class="text-blue-600 hover:text-blue-800 font-medium py-2 px-4 rounded-md w-full mt-4 hidden">Show More</button>
                </div>
                <!-- Calendar -->
                <div class="p-6 bg-red-50 rounded-lg shadow-inner">
                    <h2 class="text-xl font-bold text-red-700 mb-4">Manage Days Off</h2>
                    <div class="flex justify-between items-center mb-4">
                        <button id="prevMonthBtn" class="p-2 rounded-full hover:bg-gray-200"><</button>
                        <h3 id="calendarMonthYear" class="text-lg font-semibold"></h3>
                        <button id="nextMonthBtn" class="p-2 rounded-full hover:bg-gray-200">></button>
                    </div>
                    <div id="calendarGrid" class="grid grid-cols-7 gap-1 text-center"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modals -->
    <!-- Auth Modal -->
    <div id="authModal" class="modal">
        <div class="modal-content">
            <span id="closeAuthModalBtn" class="close-button">×</span>
            <h2 class="text-3xl font-bold text-gray-800 mb-4 text-center">Welcome!</h2>
            <p class="text-gray-600 mb-6 text-center">Sign in or create an account to save your progress.</p>
            <input type="email" id="authEmail" placeholder="Email" class="w-full p-3 mb-4 border border-gray-300 rounded-lg"/>
            <input type="password" id="authPassword" placeholder="Password" class="w-full p-3 mb-6 border border-gray-300 rounded-lg"/>
            <p id="authErrorMessage" class="text-red-500 mb-4 text-center h-5"></p>
            <div class="flex flex-col space-y-3">
                <div class="flex space-x-3 w-full">
                    <button id="signInBtn" class="flex-1 btn btn-blue">Sign In</button>
                    <button id="createAccountBtn" class="flex-1 btn btn-green">Create Account</button>
                </div>
                <button id="anonymousSignInBtn" class="w-full btn bg-gray-600 hover:bg-gray-700 text-white">Continue Anonymously</button>
            </div>
        </div>
    </div>
    <!-- Generic Message Modal -->
    <div id="messageModal" class="modal"><div class="modal-content"><span class="close-button">×</span><p id="modalMessage" class="text-gray-700 text-lg"></p><div class="mt-4 flex justify-end"><button id="modalOkBtn" class="btn btn-blue">OK</button></div></div></div>
    <!-- Generic Confirm Modal -->
    <div id="confirmModal" class="modal"><div class="modal-content"><p id="confirmMessage" class="text-gray-700 text-lg"></p><div class="mt-4 flex justify-end space-x-2"><button id="confirmCancelBtn" class="btn btn-red">Cancel</button><button id="confirmOkBtn" class="btn btn-blue">Confirm</button></div></div></div>
    <!-- Countdown Setup Modal -->
    <div id="countdownModal" class="modal"><div class="modal-content"><h3 class="text-xl font-bold mb-4">Preparation</h3><div class="space-y-4"><div><label for="countdownMinutes" class="block text-sm font-medium">Focus Session Duration (minutes)</label><input type="number" id="countdownMinutes" min="1" value="25" class="mt-1 block w-full p-2 border rounded-md"><p id="countdownError" class="text-xs text-gray-500 h-4 mt-1"></p></div><div><label for="breakIntervalMinutes" class="block text-sm font-medium">Notify for break every (minutes, optional)</label><input type="number" id="breakIntervalMinutes" min="1" class="mt-1 block w-full p-2 border rounded-md"></div><div class="p-2 bg-gray-100 rounded-md"><h4 class="text-sm font-medium text-gray-800 mb-1">My Ritual</h4><p id="ritualText" class="text-sm text-gray-600 whitespace-pre-wrap"></p></div></div><div class="mt-6 flex justify-end space-x-3"><button id="cancelCountdownBtn" class="btn bg-gray-300">Cancel</button><button id="startCountdownBtn" class="btn btn-blue">Start</button></div></div></div>
    <!-- Countdown Complete (Medal) Modal -->
    <div id="medalModal" class="modal"><div class="modal-content text-center"><div class="text-8xl mb-4">🏅</div><h3 class="text-2xl font-bold text-yellow-500 mb-2">Focus Session Complete!</h3><p class="text-gray-600">You can reflect now or continue focusing. Your overtime will be tracked.</p><div id="overtimeDisplay" class="text-3xl mt-4 font-bold text-gray-700">00:00:00</div><div class="mt-4"><input type="checkbox" id="addOvertimeCheckbox" class="h-4 w-4 rounded border-gray-300" checked><label for="addOvertimeCheckbox" class="ml-2 text-gray-700">Add overtime to session</label></div><div class="mt-6"><button id="closeMedalModalBtn" class="btn btn-blue w-full">Reflect on Session</button></div></div></div>
    <!-- Pause Prompt Modal -->
    <div id="interruptionPromptModal" class="modal"><div class="modal-content"><h3 class="text-xl font-bold mb-4">Pausing Focus</h3><p class="mb-4">Did an interruption cause you to pause?</p><div class="mt-6 flex justify-between items-center"><button id="justPauseBtn" class="btn bg-gray-400">Just Pause</button><button id="logInterruptionFromPauseBtn" class="btn btn-yellow">Log Interruption & Pause</button></div><button id="cancelPauseBtn" class="btn bg-gray-200 text-gray-800 w-full mt-4">Nevermind</button></div></div></div>
    <!-- Log Interruption Modal -->
    <div id="logInterruptionModal" class="modal"><div class="modal-content"><h3 class="text-xl font-bold mb-4">Log an Interruption</h3><div><label for="penaltyMinutesInput">Penalty Minutes (subtracted from timer)</label><input type="number" id="penaltyMinutesInput" min="0" value="5" class="mt-1 block w-full p-2 border rounded-md"><p id="penaltyErrorStatus" class="text-xs text-gray-500 h-4 mt-1"></p></div><div class="mt-6 flex justify-end space-x-3"><button id="cancelLogInterruptionBtn" class="btn bg-gray-300">Cancel</button><button id="confirmLogInterruptionBtn" class="btn btn-yellow">Log It</button></div></div></div>
    <!-- Reflection Modal -->
    <div id="reflectionModal" class="modal"><div class="modal-content"><h3 class="text-xl font-bold mb-4">Reflection</h3><div id="reflectionTimelineContainer" class="timeline-container" title="This timeline shows when interruptions occurred during your session."><div id="reflectionTimeline" class="timeline"></div></div><p id="reflectionSuggestionText" class="text-sm text-gray-600 mb-4"></p><div class="mb-4"><label class="block text-sm font-medium text-gray-700 mb-2">Focus Quality</label><div class="star-rating flex justify-center" data-rating="0"><i class="fa-solid fa-star" data-value="1"></i><i class="fa-solid fa-star" data-value="2"></i><i class="fa-solid fa-star" data-value="3"></i><i class="fa-solid fa-star" data-value="4"></i><i class="fa-solid fa-star" data-value="5"></i></div></div><div class="mt-6 flex justify-end"><button id="confirmReflectionBtn" class="btn btn-red">Next</button></div></div></div>
    <!-- Goals Modal -->
    <div id="goalsModal" class="modal"><div class="modal-content"><span class="close-button">×</span><h2 class="text-xl font-bold mb-4">Set Goals</h2><div class="space-y-4"><div><label for="todayFocusGoal">Today’s Focus Time (min)</label><input type="number" id="todayFocusGoal" min="0" class="mt-1 block w-full p-2 border rounded-md"><p id="todayFocusGoalError" class="text-xs text-gray-500 h-4 mt-1"></p></div><div><label for="scheduledSessionsGoal">Scheduled Focus Sessions</label><input type="number" id="scheduledSessionsGoal" min="0" class="mt-1 block w-full p-2 border rounded-md"><p id="scheduledSessionsGoalError" class="text-xs text-gray-500 h-4 mt-1"></p></div><div><label for="interruptionGoal">Mins per Interruption Goal</label><input type="number" id="interruptionGoal" min="0" class="mt-1 block w-full p-2 border rounded-md"><p id="interruptionGoalError" class="text-xs text-gray-500 h-4 mt-1"></p></div></div><button id="saveGoalsBtn" class="btn btn-blue mt-6 w-full">Save Goals</button></div></div></div>
    <!-- Edit Log Entry Modal -->
    <div id="editLogModal" class="modal"></div>
    <!-- Low Quality Reason Modal -->
    <div id="reasonModal" class="modal"><div class="modal-content"><h3 class="text-xl font-bold mb-4">Reason for Low Quality</h3><p class="text-sm text-gray-600 mb-4">Select a past reason or add a new one.</p><div id="pastReasonsContainer" class="flex flex-wrap gap-2 mb-4"></div><input type="text" id="newReasonInput" placeholder="New reason (e.g., Low Energy)" class="w-full p-2 border rounded-md"><div class="mt-6 flex justify-end"><button id="saveReasonBtn" class="btn btn-blue">Save & Continue</button></div></div></div>
    <!-- Improvement Modal -->
    <div id="improvementModal" class="modal"><div class="modal-content"><h3 class="text-xl font-bold mb-4">Self-Reflection</h3><p class="text-sm text-gray-600 mb-4">How could you improve this next time?</p><textarea id="improvementText" rows="3" class="w-full p-2 border rounded-md"></textarea><div class="mt-6 flex justify-end"><button id="finishReflectionBtn" class="btn btn-green">Finish</button></div></div></div>
    <!-- Ad-hoc (Stopwatch) Reflection Prompt -->
    <div id="adhocReflectionModal" class="modal"><div class="modal-content"><h3 class="text-xl font-bold mb-4">Session Ended</h3><p class="text-gray-600 mb-6">How would you like to proceed?</p><div class="flex flex-col space-y-3"><button id="adhocReflectBtn" class="btn btn-blue">Reflect on Session</button><button id="adhocSkipBtn" class="btn bg-gray-300 text-gray-800">Save & Skip Reflection</button></div></div></div>
    <!-- Early End (Countdown) Modal -->
    <div id="earlyEndModal" class="modal"><div class="modal-content"><h3 class="text-xl font-bold mb-4">Session Ended Early</h3><p class="mb-4">How should this time be logged?</p><div class="flex flex-col space-y-3"><button id="earlyEndYesBtn" class="btn btn-green">Log as Completed Session</button><button id="earlyEndNoCountBtn" class="btn btn-blue">Log Time as Ad-hoc</button><button id="earlyEndNoDiscardBtn" class="btn btn-red">Discard Session</button></div></div></div>
    
    <!-- Manage Reason Modal -->
    <div id="manageReasonModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="this.parentElement.parentElement.style.display='none'">×</span>
            <h3 class="text-xl font-bold mb-4">Manage Reason</h3>
            <input type="hidden" id="originalReasonInput">
            
            <div class="mb-4">
                <label for="renameReasonInput" class="block text-sm font-medium text-gray-700">Rename Reason</label>
                <div class="flex mt-1">
                    <input type="text" id="renameReasonInput" class="flex-1 p-2 border rounded-l-md">
                    <button id="saveRenameBtn" class="btn btn-blue rounded-l-none">Save</button>
                </div>
            </div>

            <div class="mb-4">
                <label for="reassignReasonSelect" class="block text-sm font-medium text-gray-700">Re-assign all entries to</label>
                <div class="flex mt-1">
                    <select id="reassignReasonSelect" class="flex-1 p-2 border rounded-l-md"></select>
                    <button id="confirmReassignBtn" class="btn btn-orange rounded-l-none">Re-assign</button>
                </div>
            </div>

            <div class="mt-6 border-t pt-4">
                <button id="deleteReasonBtn" class="btn btn-red w-full">Delete This Reason Entirely</button>
            </div>
        </div>
    </div>
    
    <!-- Extended Break Modal -->
    <div id="extendedBreakModal" class="modal"><div class="modal-content"><h3 class="text-xl font-bold mb-4">Welcome Back!</h3><p id="extendedBreakMessage" class="mb-4"></p><div class="flex flex-col space-y-3"><button id="continueSessionBtn" class="btn btn-blue">Continue Session</button><button id="endCurrentSessionBtn" class="btn btn-orange">End Current Session</button></div></div></div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="this.parentElement.parentElement.style.display='none'">×</span>
            <h3 class="text-xl font-bold mb-4">Settings</h3>
            <div class="space-y-6">
                 <div>
                    <label for="settingsSpotifyLink" class="block text-sm font-medium text-gray-700">Custom Spotify Link</label>
                    <input type="text" id="settingsSpotifyLink" class="mt-1 block w-full p-2 border rounded-md" placeholder="e.g., https://open.spotify.com/playlist/..."/>
                    <p class="text-xs text-gray-500 mt-1">You can paste any Spotify link (e.g., artist, playlist, or album). Regional codes and tracking info will be removed automatically.</p>
                    <p id="spotifySaveStatus" class="text-xs text-gray-500 h-4 mt-1"></p>
                </div>
                <div>
                    <label for="settingsMinSessionLength" class="block text-sm font-medium text-gray-700">Minimum Session Length (min)</label>
                    <input type="number" id="settingsMinSessionLength" class="mt-1 block w-full p-2 border rounded-md" placeholder="e.g., 15">
                     <p class="text-xs text-gray-500 mt-1">This helps ensure you give your brain enough time to enter a state of deep focus.</p>
                    <p id="minSessionSaveStatus" class="text-xs text-gray-500 h-4 mt-1"></p>
                </div>
                <div>
                    <label for="settingsRitualText" class="block text-sm font-medium text-gray-700">My Preparation Ritual</label>
                    <textarea id="settingsRitualText" rows="4" class="mt-1 block w-full p-2 border rounded-md" placeholder="e.g., Turn off notifications, put phone away..."></textarea>
                    <p id="ritualSaveStatus" class="text-xs text-gray-500 h-4 mt-1"></p>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700">My Break Activities</label>
                    <div class="flex mt-1">
                         <input type="text" id="newBreakActivityInput" class="flex-1 p-2 border rounded-l-md" placeholder="e.g., 5-minute walk"/>
                         <button id="addBreakActivityBtn" class="btn btn-green rounded-l-none">Add</button>
                    </div>
                    <p id="breakActivitySaveStatus" class="text-xs text-gray-500 h-4 mt-1"></p>
                    <ul id="breakActivitiesList" class="mt-2 space-y-2 max-h-40 overflow-y-auto"></ul>
                </div>
            </div>
        </div>
    </div>


    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { getFirestore, doc, collection, onSnapshot, setDoc, updateDoc, deleteDoc, getDoc, query, arrayUnion, arrayRemove, writeBatch } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
        
        // --- Firebase Configuration ---
        // (Using your provided dev config as a fallback)
        const yourOwnFirebaseConfig = {
            apiKey: "AIzaSyBr9SxXKQYKFWwARZtmv4jxPW5w579tUjY",
            authDomain: "focus-time-tracker-7757a.firebaseapp.com",
            projectId: "focus-time-tracker-7757a",
            storageBucket: "focus-time-tracker-7757a.firebasestorage.app",
            messagingSenderId: "795437053011",
            appId: "1:795437053011:web:fcab00d7a8d119762902a6"
        };
        // Use environment variables if available, otherwise fall back
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : yourOwnFirebaseConfig;
        const APP_ID_FOR_FIRESTORE = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        // --- Firebase Services ---
        let app, auth, db;
        try {
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
        } catch (e) {
            console.error("Firebase initialization failed:", e);
            document.getElementById('loadingMessage').textContent = "Error: Could not connect to services.";
        }
        
        // --- Global State Variables ---
        let currentUser = null, userId = null, isAuthReady = false, unsubscribe = {}, chartInstance;
        let timerInterval, startTime, running = false, isSaving = false, accumulatedTime = 0, countdownDuration = 0;
        let sessionAbsoluteStartTime = null;
        let focusedTimeData = {}, goals = {}, daysOff = {}, lowQualityReasons = [];
        let notificationTimeoutId, notificationsEnabled, focusMusicEnabled;
        let calendarDate = new Date(), currentTimerMode = 'stopwatch', showAllLogEntries = false;
        let sessionDataForReflection = null;
        let sessionInterruptionTimestamps = [], sessionPauseEvents = [];

        let breakInterval = 0, breakTimerInterval, breakStartTime, lastContinueTime, breakNotificationShown = false;
        let overtimeInterval, overtimeStartTime, lastPauseStartTime = null;
        let userSettings = { ritual: '', breakActivities: [], spotifyLink: '', minSessionLength: null };
        let settingsSaveTimers = {};
        let displayedDate = null;
        let uiUpdateTimeout;
        let lastPenaltyResetTime = null;

        /**
         * Debounces UI updates to prevent rapid, unnecessary re-renders.
         */
        function debounceUpdateUI() {
            clearTimeout(uiUpdateTimeout);
            uiUpdateTimeout = setTimeout(updateAllUI, 50);
        }

        /**
         * Main initialization on DOM content loaded.
         */
        document.addEventListener('DOMContentLoaded', () => {
            // Load persistent toggle states from localStorage
            notificationsEnabled = localStorage.getItem('notificationToggleState') === 'true';
            document.getElementById('notificationToggle').checked = notificationsEnabled;
            focusMusicEnabled = localStorage.getItem('focusMusicToggleState') === 'true';
            document.getElementById('focusMusicToggle').checked = focusMusicEnabled;
            // Default manual entry date to today
            document.getElementById('newEntryDate').value = new Date().toISOString().slice(0, 10);
            
            // Firebase Auth State Listener
            onAuthStateChanged(auth, user => {
                // Clear any existing data listeners
                Object.values(unsubscribe).forEach(unsub => unsub());
                unsubscribe = {};
                currentUser = user;
                if (user) {
                    userId = user.uid;
                    hideAuthModal();
                    attachDataListeners(); // Attach listeners for the new user
                } else {
                    userId = null;
                    clearUserData(); // Clear local data
                    showAuthModal(); // Show login
                }
                updateAuthUI();
                if (!isAuthReady) {
                    isAuthReady = true;
                    document.getElementById('loadingMessage').classList.add('hidden');
                }
            });
            setupEventListeners();
            // Periodically check goals and date
            setInterval(() => {
                checkAndManageGoalsUI();
                updateDashboardDate();
            }, 30 * 1000);
        });
        
        /**
         * Attaches real-time Firestore listeners for user data.
         */
        function attachDataListeners() {
            if (!userId) return;
            let dataLoaded = { focusSessions: false, goals: false, daysOff: false, reasons: false, settings: false };
            const checkAllDataLoaded = () => { if (Object.values(dataLoaded).every(v => v)) updateAllUI(); };
            
            const createSnapshotHandler = (collectionName, dataProcessor) => {
                return (snapshot) => {
                    dataProcessor(snapshot);
                    if (!dataLoaded[collectionName]) {
                        dataLoaded[collectionName] = true;
                        checkAllDataLoaded();
                    } else if (isAuthReady) {
                        debounceUpdateUI();
                    }
                };
            };

            // Listener for 'focusSessions'
            const collections = {
                focusSessions: createSnapshotHandler('focusSessions', snapshot => {
                    snapshot.docChanges().forEach((change) => {
                        const docId = change.doc.id;
                        if (change.type === "removed") {
                            delete focusedTimeData[docId];
                        } else { // 'added' or 'modified'
                            focusedTimeData[docId] = change.doc.data();
                        }
                    });
                }),
                goals: createSnapshotHandler('goals', s => { goals = {}; s.forEach(d => { goals[d.id] = d.data() }); }),
                daysOff: createSnapshotHandler('daysOff', s => { daysOff = {}; s.forEach(d => { daysOff[d.id] = d.data() }); }),
            };

            Object.entries(collections).forEach(([col, handler]) => {
                const q = query(collection(db, `artifacts/${APP_ID_FOR_FIRESTORE}/users/${userId}/${col}`));
                unsubscribe[col] = onSnapshot(q, handler, err => console.error(`Error on ${col}:`, err));
            });

            // Listener for 'reasons' (single doc)
            const reasonsDocRef = doc(db, `artifacts/${APP_ID_FOR_FIRESTORE}/users/${userId}/reflectionData/reasons`);
            unsubscribe.reasons = onSnapshot(reasonsDocRef, createSnapshotHandler('reasons', docSnap => {
                lowQualityReasons = docSnap.exists() ? docSnap.data().reasons : [];
            }));

            // Listener for 'settings' (single doc)
            const settingsDocRef = doc(db, `artifacts/${APP_ID_FOR_FIRESTORE}/users/${userId}/settings/main`);
            unsubscribe.settings = onSnapshot(settingsDocRef, createSnapshotHandler('settings', docSnap => {
                userSettings = docSnap.exists() ? { ...{ ritual: '', breakActivities: [], spotifyLink: '', minSessionLength: null }, ...docSnap.data() } : { ritual: '', breakActivities: [], spotifyLink: '', minSessionLength: null };
            }));
        }

        /**
         * Clears all local user data on sign-out.
         */
        function clearUserData() {
            focusedTimeData = {};
            goals = {}; daysOff = {}; userSettings = { ritual: '', breakActivities: [], spotifyLink: '', minSessionLength: null };
            if(chartInstance) chartInstance.destroy();
            updateAllUI();
        }
        
        /**
         * Displays the authentication modal.
         */
        function showAuthModal() {
            const closeBtn = document.getElementById('closeAuthModalBtn'), anonBtn = document.getElementById('anonymousSignInBtn');
            if (currentUser && currentUser.isAnonymous) { closeBtn.style.display = 'block'; anonBtn.style.display = 'none'; }
            else { closeBtn.style.display = 'none'; anonBtn.style.display = 'block'; }
            document.getElementById('authModal').style.display = 'flex';
            document.getElementById('appSection').classList.add('hidden');
        }

        /**
         * Hides the authentication modal.
         */
        function hideAuthModal() {
            document.getElementById('authModal').style.display = 'none';
            document.getElementById('authErrorMessage').textContent = '';
            document.getElementById('appSection').classList.remove('hidden');
        }

        /**
         * Updates the auth-related UI (sign-in/out buttons, user email).
         */
        function updateAuthUI() {
            const authContainer = document.getElementById('authContainer');
            authContainer.innerHTML = ''; // Clear existing buttons
            if (currentUser) {
                const userInfoEl = document.createElement('span');
                userInfoEl.className = 'text-gray-600 text-sm hidden sm:block'; authContainer.appendChild(userInfoEl);
                // Settings Button
                const settingsBtn = document.createElement('button'); settingsBtn.id = 'settingsBtn';
                settingsBtn.className = 'p-2 bg-gray-200 hover:bg-gray-300 rounded-full transition-all'; settingsBtn.title = 'Settings';
                settingsBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-settings text-gray-600"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 0 2.12l-.15.1a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.38a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1 0-2.12l.15-.1a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>`;
                settingsBtn.addEventListener('click', openSettingsModal); authContainer.appendChild(settingsBtn);
                
                if (currentUser.isAnonymous) {
                    userInfoEl.textContent = 'Anonymous User';
                    const registerBtn = document.createElement('button'); registerBtn.className = 'btn btn-green text-sm py-2 px-4'; registerBtn.textContent = 'Sign In / Register'; registerBtn.addEventListener('click', showAuthModal); authContainer.appendChild(registerBtn);
                } else {
                    userInfoEl.textContent = currentUser.email;
                    const signOutBtn = document.createElement('button'); signOutBtn.className = 'p-2 bg-gray-200 hover:bg-gray-300 rounded-full transition-all'; signOutBtn.title = 'Sign Out';
                    signOutBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-gray-600"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"/><polyline points="17 16 22 12 17 8"/><line x1="22" y1="12" x2="10" y2="12"/></svg>`;
                    signOutBtn.addEventListener('click', () => signOut(auth)); authContainer.appendChild(signOutBtn);
                }
            } else {
                const signInBtn = document.createElement('button');
                signInBtn.className = 'btn btn-blue'; signInBtn.textContent = 'Sign In / Register'; signInBtn.addEventListener('click', showAuthModal); authContainer.appendChild(signInBtn);
            }
        }

        /**
         * Updates all major UI components. Called after data changes.
         */
        function updateAllUI() {
            if (!isAuthReady || !currentUser) return;
            updateDashboardDate();
            checkAndManageGoalsUI(); updateDashboard(); renderCalendar(); renderLog();
            if (document.getElementById('chartTypeSelect').value === 'interruptionLikelihood') {
                setupComparisonControls();
            } else {
                renderChart();
            }
        }

        /**
         * Updates the dashboard title with the current date.
         */
        function updateDashboardDate() {
            const today = new Date();
            const day = String(today.getDate()).padStart(2, '0');
            const month = String(today.getMonth() + 1).padStart(2, '0');
            const year = today.getFullYear();
            const todayStr = `${day}.${month}.${year}`;
            if (displayedDate !== todayStr) {
                document.getElementById('kpiDashboardTitle').textContent = `KPI Dashboard ${todayStr}`;
                displayedDate = todayStr;
                updateDashboard();
            }
        }
        
        /**
         * Formats seconds into HH:MM:SS string.
         * @param {number} s - Total seconds.
         * @returns {string} Formatted time string.
         */
        function formatTimer(s) {
            s = Math.max(0, s);
            const h = String(Math.floor(s / 3600)).padStart(2, '0'), m = String(Math.floor((s % 3600) / 60)).padStart(2, '0'), sec = String(Math.floor(s % 60)).padStart(2, '0');
            return `${h}:${m}:${sec}`;
        }
        
        /**
         * Updates the main timer display and break countdown.
         */
        function updateTimerDisplay() {
            const elapsedSeconds = accumulatedTime / 1000 + (running ? (Date.now() - startTime) / 1000 : 0);
            const displaySeconds = (currentTimerMode === 'stopwatch') ? elapsedSeconds : Math.max(0, countdownDuration - elapsedSeconds);
            document.getElementById('timeValue').textContent = formatTimer(displaySeconds);
            document.getElementById('sessionInterruptionsDisplay').textContent = sessionInterruptionTimestamps.length;
            
            // Handle break notification countdown
            const nextBreakEl = document.getElementById('nextBreakCountdown');
            if (running && currentTimerMode === 'countdown' && breakInterval > 0 && lastContinueTime) {
                const elapsedSinceContinue = (Date.now() - lastContinueTime) / 1000;
                const secondsToNextBreak = breakInterval - elapsedSinceContinue;
                
                if (secondsToNextBreak <= 0) {
                    nextBreakEl.textContent = "Time for a break! ☕️";
                    nextBreakEl.classList.remove('hidden');
                    if (!breakNotificationShown) {
                        if (Notification.permission === 'granted') {
                            new Notification('Time for a break!', { body: 'Step away for a few minutes to refresh.', icon: "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>☕️</text></svg>" });
                        }
                        breakNotificationShown = true;
                    }
                } else if (displaySeconds > secondsToNextBreak) {
                    nextBreakEl.textContent = `Next Pause In: ${Math.ceil(secondsToNextBreak / 60)} min`;
                    nextBreakEl.classList.remove('hidden');
                } else {
                    nextBreakEl.classList.add('hidden');
                }
            } else {
                 nextBreakEl.classList.add('hidden');
            }
            // Check for countdown completion
            if (currentTimerMode === 'countdown' && displaySeconds <= 0 && running) { completeCountdown();
            }
        }

        /**
         * Handles the completion of a countdown session.
         */
        function completeCountdown() {
            if (isSaving) return;
            running = false; 
            clearInterval(timerInterval);
            
            new Audio("https://actions.google.com/sounds/v1/impacts/gong_strike.ogg").play().catch(e => console.warn("Audio fail:", e));
            if (Notification.permission === 'granted') { new Notification('Focus session complete!', { body: 'Great work! Time to reflect.', icon: "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>🏅</text></svg>"});
            }
            
            accumulatedTime = countdownDuration * 1000;
            handleEndFocus(true); // 'true' indicates a completed session
        }
        
        /**
         * Toggles the timer on/off. Handles pause logic.
         */
        function toggleTimer() {
            // If running, show pause prompt
            if (running) { 
                document.getElementById('interruptionPromptModal').style.display = 'flex';
                return;
            }

            // If resuming from a pause, check for extended break
            if(lastPauseStartTime) {
                const breakDuration = Date.now() - lastPauseStartTime;
                const accumulatedMinutes = accumulatedTime / 1000 / 60;
                // Determine break threshold
                let thresholdMinutes;
                if (accumulatedMinutes < 45) {
                    thresholdMinutes = 10;
                } else if (accumulatedMinutes < 60) {
                    thresholdMinutes = 15;
                } else if (accumulatedMinutes < 75) {
                    thresholdMinutes = 20;
                } else {
                    thresholdMinutes = 30;
                }

                if (breakDuration > thresholdMinutes * 60 * 1000) {
                    document.getElementById('extendedBreakMessage').textContent = `You've been on a break for ${Math.round(breakDuration / (60 * 1000))} minutes. Would you like to continue this session or end it?`;
                    document.getElementById('extendedBreakModal').style.display = 'flex';
                    lastPauseStartTime = null; 
                    return;
                }
                lastPauseStartTime = null;
            }
            
            // If starting a new countdown, show setup modal
            if (currentTimerMode === 'countdown' && countdownDuration === 0) {
                const countdownMinutesInput = document.getElementById('countdownMinutes');
                const minLength = userSettings.minSessionLength;
                if (minLength && minLength > 0) {
                    countdownMinutesInput.value = minLength;
                } else {
                    countdownMinutesInput.value = 25; // Default
                }
                
                // Validate the default/pre-filled value
                const startCountdownBtn = document.getElementById('startCountdownBtn');
                const countdownErrorEl = document.getElementById('countdownError');
                if (minLength && minLength > 0 && parseInt(countdownMinutesInput.value) < minLength) {
                    countdownErrorEl.textContent = `It takes time to build focus. Try a session of at least ${minLength} minutes.`;
                    startCountdownBtn.disabled = true;
                } else {
                    countdownErrorEl.textContent = '';
                    startCountdownBtn.disabled = false;
                }
                
                document.getElementById('ritualText').textContent = userSettings.ritual || 'No ritual set. Go to Settings to add one.';
                document.getElementById('countdownModal').style.display = 'flex';
            } else { 
                // Otherwise, just start/resume
                startTimer();
            }
        }
        
        /**
         * Starts the timer interval and updates UI.
         */
        function startTimer() {
            if (running) return;
            if (accumulatedTime === 0) {
                sessionAbsoluteStartTime = Date.now();
                lastPenaltyResetTime = sessionAbsoluteStartTime;
            } else {
                lastPenaltyResetTime = Date.now();
            }

            // Log end of pause
            if (sessionPauseEvents.length > 0 && !sessionPauseEvents[sessionPauseEvents.length - 1].end) {
                const currentTotalElapsed = (sessionAbsoluteStartTime ? Date.now() - sessionAbsoluteStartTime : 0) / 1000;
                sessionPauseEvents[sessionPauseEvents.length - 1].end = currentTotalElapsed;
            }
            stopBreakTimer();
            running = true; startTime = Date.now();
            breakNotificationShown = false; // Reset break notification flag
            
            // Set time for next break
            const remainingTime = countdownDuration - (accumulatedTime / 1000);
            if (currentTimerMode === 'countdown' && breakInterval > 0 && remainingTime > breakInterval) {
                 lastContinueTime = Date.now();
            } else {
                lastContinueTime = null;
            }
            
            timerInterval = setInterval(updateTimerDisplay, 500);
            document.getElementById('togglePauseBtn').textContent = 'Pause'; document.getElementById('togglePauseBtn').classList.replace('btn-green', 'btn-orange'); document.getElementById('logInterruptionBtn').disabled = false;
            if (notificationsEnabled) scheduleNextNotification();
            if (focusMusicEnabled) {
                launchSpotify();
            }
        }
        
        /**
         * Pauses the timer interval and updates UI.
         */
        function pauseTimer() {
            if (!running) return;
            document.getElementById('nextBreakCountdown').classList.add('hidden');
            running = false; clearInterval(timerInterval); accumulatedTime += Date.now() - startTime;
            lastPauseStartTime = Date.now();
            
            // Log start of pause
            const currentTotalElapsed = (sessionAbsoluteStartTime ? (Date.now() - sessionAbsoluteStartTime) : accumulatedTime) / 1000;
            sessionPauseEvents.push({ start: currentTotalElapsed, end: null });

            document.getElementById('togglePauseBtn').textContent = 'Continue'; document.getElementById('togglePauseBtn').classList.replace('btn-orange', 'btn-green'); document.getElementById('logInterruptionBtn').disabled = true; clearTimeout(notificationTimeoutId);
            startBreakTimer();
        }
        
        /**
         * Shows the reflection modal and renders the session timeline.
         * @param {object} details - The session data for reflection.
         */
        function showReflectionModal(details) {
            sessionDataForReflection = details;
            const modal = document.getElementById('reflectionModal');
            modal.style.display = 'flex'; 

            // --- Timeline Rendering ---
            const timelineContainer = document.getElementById('reflectionTimelineContainer');
            const timeline = document.getElementById('reflectionTimeline');
            
            timeline.innerHTML = '';
            timelineContainer.querySelectorAll('.timeline-marker').forEach(m => m.remove());

            const totalSessionTime = details.totalSessionDuration / 1000;
            if (totalSessionTime <= 0) return;

            const totalSessionMinutes = totalSessionTime / 60;
            const normalizedInterruptions = (details.interruptions || []).map(i =>
                (typeof i === 'number') ? { time: i, penalty: 0 } : i
            );

            // Create a sorted list of all event time points
            const eventPoints = new Set([0, totalSessionTime]);
            details.pauseEvents?.forEach(p => {
                eventPoints.add(p.start);
                eventPoints.add(p.end);
            });
            normalizedInterruptions.forEach(i => {
                eventPoints.add(i.time);
                eventPoints.add(i.time - i.penalty);
            });
            const sortedPoints = Array.from(eventPoints).filter(p => p >= 0 && p <= totalSessionTime).sort((a, b) => a - b);
            
            // Create segments between each event point
            for (let i = 0; i < sortedPoints.length - 1; i++) {
                const start = sortedPoints[i];
                const end = sortedPoints[i+1];
                const midPoint = start + (end - start) / 2;

                let segmentType = 'focus'; // Default to focus
                
                // Check for breaks
                if (details.pauseEvents?.some(p => midPoint >= p.start && midPoint < p.end)) {
                    segmentType = 'break';
                }
                
                // Check for penalties (they overlay focus)
                let isPenalty = normalizedInterruptions.some(p => midPoint >= (p.time - p.penalty) && midPoint < p.time);

                const segment = document.createElement('div');
                segment.className = 'timeline-segment';
                const startPercent = (start / totalSessionTime) * 100;
                const widthPercent = ((end - start) / totalSessionTime) * 100;
                segment.style.left = `${startPercent}%`;
                segment.style.width = `${widthPercent}%`;
                
                if (segmentType === 'break') {
                    segment.classList.add('timeline-break');
                    segment.title = `Break: ${Math.round((end - start)/60)} min`;
                } else {
                    // It's a focus block, draw it
                    const focusSegment = document.createElement('div');
                    focusSegment.className = 'timeline-segment timeline-focus';
                    focusSegment.style.left = `${startPercent}%`;
                    focusSegment.style.width = `${widthPercent}%`;
                    timeline.appendChild(focusSegment);

                    if (isPenalty) {
                        // If it's also a penalty, draw penalty segment over it
                        segment.classList.add('timeline-penalty');
                        segment.title = `Penalty`;
                    } else {
                        continue; // No separate div needed if just focus
                    }
                }
                 timeline.appendChild(segment);
            }
            
            // Draw interruption dots
            normalizedInterruptions.forEach(interruption => {
                const dot = document.createElement('div');
                dot.className = 'timeline-dot';
                dot.style.left = `${(interruption.time / totalSessionTime) * 100}%`;
                dot.title = `Interruption at ~${Math.round(interruption.time/60)} min`;
                timeline.appendChild(dot);
            });
            
            // Draw time markers
            const timelineWidth = timeline.offsetWidth;
            if (timelineWidth > 0) {
                const minMarkerPixelSpacing = 40;
                let interval = 1; 
                if (totalSessionMinutes > 5) interval = 5;
                if (totalSessionMinutes > 25) interval = 10;
                if (totalSessionMinutes > 50) interval = 15;
                
                while ((interval / totalSessionMinutes) * timelineWidth < minMarkerPixelSpacing && interval < totalSessionMinutes / 2) {
                   if (interval < 5) interval = 5;
                   else if(interval < 10) interval = 10; else interval += 10;
                }
                for (let min = interval; min < totalSessionMinutes; min += interval) {
                    const marker = document.createElement('div');
                    marker.className = 'timeline-marker';
                    marker.textContent = `${min}m`;
                    marker.style.left = `${(min / totalSessionMinutes) * 100}%`;
                    timelineContainer.appendChild(marker);
                }
            }

            // --- Star Rating ---
            const stars = modal.querySelectorAll('.star-rating .fa-star');
            const suggestion = getHistoricalRatingSuggestion(details.duration, normalizedInterruptions);
            let suggestionText = `With ${normalizedInterruptions.length} interruptions and this focus duration, we suggest a quality rating of ${suggestion} stars.`;
            document.getElementById('reflectionSuggestionText').textContent = suggestionText;
            stars.forEach(s => s.classList.remove('selected'));
            for (let i = 0; i < suggestion; i++) { stars[i].classList.add('selected');
            }
            modal.querySelector('.star-rating').dataset.rating = suggestion;
            setupStarRating(modal.querySelector('.star-rating'));
        }

        /**
         * Saves the completed session data to Firestore.
         * @param {object} details - The complete session data to save.
         */
        async function stopAndSaveSession(details) {
            const { duration, interruptions = [], pauseEvents = [], quality = null, reason = null, type } = details;
            // Prevent saving empty or in-progress sessions
            if (isSaving || !Number.isFinite(duration) || duration <= 0) { 
                resetTimerState();
                return; 
            } 
            isSaving = true;
            const today = new Date().toISOString().slice(0, 10);
            const newSession = { 
                id: crypto.randomUUID(), 
                duration: Math.floor(duration / 1000), // Save as seconds
                interruptions, 
                pauseEvents,
                quality, 
                reason, 
                timestamp: new Date().toISOString(), 
                type 
            };

            // Optimistic UI update
            if (!focusedTimeData[today]) {
                focusedTimeData[today] = { sessions: [] };
            }
            if (!focusedTimeData[today].sessions.find(s => s.id === newSession.id)) {
                focusedTimeData[today].sessions.push(newSession);
            }
            debounceUpdateUI();

            // Save to Firestore
            try {
                const docRef = doc(db, `artifacts/${APP_ID_FOR_FIRESTORE}/users/${userId}/focusSessions`, today);
                const docSnap = await getDoc(docRef);
                const existing = docSnap.exists() && docSnap.data().sessions ? docSnap.data().sessions.filter(s => s.id !== newSession.id) : [];
                await setDoc(docRef, { sessions: [...existing, newSession] }, { merge: true });
                // Add new reason to the global list if it doesn't exist
                if (reason && !lowQualityReasons.includes(reason)) {
                    const reasonsRef = doc(db, `artifacts/${APP_ID_FOR_FIRESTORE}/users/${userId}/reflectionData/reasons`);
                    await setDoc(reasonsRef, { reasons: arrayUnion(reason) }, { merge: true });
                }
            } catch (e) { showMessage("Could not save session: " + e.message);
            }
            resetTimerState(); isSaving = false;
        }

        /**
         * Resets all timer-related state variables and UI.
         */
        function resetTimerState() {
            running = false;
            clearInterval(timerInterval); stopBreakTimer(); clearInterval(overtimeInterval);
            clearTimeout(notificationTimeoutId);
            overtimeInterval = null; overtimeStartTime = null; accumulatedTime = 0; 
            sessionInterruptionTimestamps = []; sessionPauseEvents = [];
            sessionAbsoluteStartTime = null;
            countdownDuration = 0; breakInterval = 0; isSaving = false; sessionDataForReflection = null;
            lastContinueTime = null;
            lastPenaltyResetTime = null;
            lastPauseStartTime = null;
            updateTimerDisplay();
            document.getElementById('togglePauseBtn').textContent = 'Start Focusing'; document.getElementById('togglePauseBtn').classList.replace('btn-orange', 'btn-green'); document.getElementById('logInterruptionBtn').disabled = true;
        }
        
        /**
         * Checks if all goals for a specific day are met.
         * @param {string} dateStr - The date string (YYYY-MM-DD).
         * @returns {boolean} True if all set goals are met.
         */
        function checkAllGoalsMet(dateStr) {
            const dayGoals = goals[dateStr];
            if (!dayGoals) return false; // No goals set

            const { dailyGoal = 0, scheduledSessionsGoal = 0, interruptionGoal = 0 } = dayGoals;
            if (dailyGoal === 0 && scheduledSessionsGoal === 0 && interruptionGoal === 0) return false; // No goals set
            
            const daySessions = focusedTimeData[dateStr]?.sessions || [];

            // 1. Check Focus Time Goal
            const totalSeconds = daySessions.reduce((sum, s) => sum + s.duration, 0);
            const totalMinutes = totalSeconds / 60;
            if (dailyGoal > 0 && totalMinutes < dailyGoal) {
                return false;
            }

            // 2. Check Focus Sessions Goal
            const completedSessions = daySessions.filter(s => s.type === 'countdown').length;
            if (scheduledSessionsGoal > 0 && completedSessions < scheduledSessionsGoal) {
                return false;
            }

            // 3. Check Mins/Interruption Goal
            const relevantSessions = daySessions.filter(s => !s.isManual || (s.isManual && s.interruptions != null));
            const totalDurationForMpi = relevantSessions.reduce((sum, s) => sum + s.duration, 0);
            const totalInterruptions = relevantSessions.reduce((sum, s) => sum + (s.interruptions?.length || 0), 0);
            const minsPerInterruption = totalDurationForMpi > 0 ? (totalDurationForMpi / 60) / (totalInterruptions + 1) : 0;
            
            if (interruptionGoal > 0 && minsPerInterruption < interruptionGoal) {
                return false;
            }
            return true; // All set goals are met
        }

        /**
         * Updates the KPI dashboard with today's stats.
         */
        function updateDashboard() {
            const todayStr = new Date().toISOString().slice(0, 10);
            const todaysGoalData = goals[todayStr];
            const todaySessions = focusedTimeData[todayStr]?.sessions || [];
            
            // Focus Time Progress
            const totalSecondsToday = todaySessions.reduce((sum, s) => sum + s.duration, 0);
            const totalMinutesToday = Math.floor(totalSecondsToday / 60);
            const dailyGoal = todaysGoalData?.dailyGoal ?? 0;
            document.getElementById('todayProgressBar').style.width = `${dailyGoal > 0 ? Math.min(100, (totalMinutesToday / dailyGoal) * 100) : 0}%`;
            document.getElementById('todayProgressText').textContent = `${totalMinutesToday} / ${dailyGoal} min`;
            
            // Sessions Progress
            const scheduledSessions = todaysGoalData?.scheduledSessionsGoal ?? 0;
            const completedSessions = todaySessions.filter(s => s.type === 'countdown').length;
            document.getElementById('sessionsProgressBar').style.width = `${scheduledSessions > 0 ? Math.min(100, (completedSessions / scheduledSessions) * 100) : 0}%`;
            document.getElementById('sessionsProgressText').textContent = `${completedSessions} / ${scheduledSessions}`;
            
            // Streak Calculation
            let streak = 0;
            let d = new Date();
            if (!checkAllGoalsMet(new Date().toISOString().slice(0, 10))) {
                d.setDate(d.getDate() - 1); // Start from yesterday if today not met
            }
            while (true) {
                const dateStr = d.toISOString().slice(0, 10);
                if (isDayOff(dateStr)) {
                    d.setDate(d.getDate() - 1);
                    continue; // Skip days off
                }
                if (checkAllGoalsMet(dateStr)) {
                    streak++;
                    d.setDate(d.getDate() - 1);
                } else {
                    break; // Streak broken
                }
            }
            document.getElementById('streakText').textContent = `${streak} Days`;

            // Mins per Interruption
            const relevantSessionsForMpi = todaySessions.filter(s => !s.isManual || (s.isManual && s.interruptions != null));
            const totalDurationForMpi = relevantSessionsForMpi.reduce((sum, s) => sum + s.duration, 0);
            const totalInterruptionsForMpi = relevantSessionsForMpi.reduce((sum, s) => sum + (s.interruptions?.length || 0), 0);
            const minsPerInterruptionToday = totalDurationForMpi > 0 ? Math.floor((totalDurationForMpi / 60) / (totalInterruptionsForMpi + 1)) : 0;

            const goalMinsPerInterruption = todaysGoalData?.interruptionGoal ?? 0;
            const container = document.getElementById('minsPerInterruptionContainer');
            let comparisonHTML = '';
            if (goalMinsPerInterruption > 0) {
                const symbol = minsPerInterruptionToday >= goalMinsPerInterruption ? '≥' : '<';
                comparisonHTML = `<span class="text-gray-500 text-2xl font-bold mx-2">${symbol}</span> <p class="text-2xl font-bold text-red-500">${goalMinsPerInterruption} min</p>`;
            }
            container.innerHTML = `<p id="minsPerInterruptionText" class="text-2xl font-bold text-red-500">${minsPerInterruptionToday} min</p>${comparisonHTML}`;
            // Max Uninterrupted Focus
            const maxFocus = calculateMaxUninterruptedFocus(todayStr, true);
            document.getElementById('maxFocusText').textContent = `${Math.floor(maxFocus / 60)} min`;
        }
        
        /**
         * Calculates the longest single focus segment for a given day.
         * @param {string} dateStr - The date string (YYYY-MM-DD).
         * @param {boolean} excludeManual - Whether to exclude manual entries.
         * @returns {number} The max focus time in seconds.
         */
        function calculateMaxUninterruptedFocus(dateStr, excludeManual = false) {
            const sessions = (focusedTimeData[dateStr]?.sessions || []).filter(s => !s.isManual);
            let maxFocus = 0;
            sessions.forEach(s => {
                const interruptions = (s.interruptions || []).map(i => (typeof i === 'number') ? { time: i, penalty: 0 } : i);
                if (interruptions.length === 0) {
                    if (s.duration > maxFocus) maxFocus = s.duration;
                } else {
                    let lastTimestamp = 0;
                    interruptions.sort((a,b) => a.time - b.time).forEach(interruption => {
                        const segmentDuration = (interruption.time - interruption.penalty) - lastTimestamp;
                        if (segmentDuration > maxFocus) maxFocus = segmentDuration;
                        lastTimestamp = interruption.time;
                    });
                    if ((s.duration - lastTimestamp) > maxFocus) maxFocus = s.duration - lastTimestamp;
                }
            });
            return maxFocus;
        }

        /**
         * Checks if a given date is a day off.
         * @param {string} dateStr - The date string (YYYY-MM-DD).
         * @returns {boolean} True if it's a day off.
         */
        function isDayOff(dateStr) {
            const d = new Date(dateStr + 'T12:00:00Z');
            const day = d.getUTCDay(); const isWknd = day === 0 || day === 6; const dayOff = daysOff[dateStr];
            return dayOff ? !dayOff.isWorkDay : isWknd; // Explicitly set day off, or default to weekend
        }

        /**
         * Renders the "Days Off" calendar.
         */
        function renderCalendar() {
            const grid = document.getElementById('calendarGrid');
            grid.innerHTML = ''; calendarDate.setDate(1); const month = calendarDate.getMonth(), year = calendarDate.getFullYear();
            document.getElementById('calendarMonthYear').textContent = `${calendarDate.toLocaleString('default', { month: 'long' })} ${year}`;
            const firstDay = calendarDate.getDay(); const daysInMonth = new Date(year, month + 1, 0).getDate();
            // Add day headers
            ['S', 'M', 'T', 'W', 'T', 'F', 'S'].forEach(d => { grid.innerHTML += `<div class="font-bold text-gray-500 text-sm">${d}</div>` });
            // Add empty cells for first day offset
            for (let i = 0; i < firstDay; i++) { grid.appendChild(document.createElement('div'));
            }
            // Add day cells
            for (let i = 1; i <= daysInMonth; i++) {
                const dayEl = document.createElement('div');
                dayEl.textContent = i;
                const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(i).padStart(2, '0')}`;
                dayEl.className = 'calendar-day cursor-pointer p-2 rounded-full text-sm';
                if (isDayOff(dateStr)) { dayEl.classList.add('day-off-explicit'); }
                if (i === new Date().getDate() && month === new Date().getMonth() && year === new Date().getFullYear()) { dayEl.classList.add('today'); // Highlight today
                }
                dayEl.addEventListener('click', () => toggleDayOff(dateStr));
                grid.appendChild(dayEl);
            }
        }

        /**
         * Toggles a day as a work day or day off in Firestore.
         * @param {string} d - The date string (YYYY-MM-DD).
         */
        async function toggleDayOff(d) {
            if (!userId) return;
            const docRef = doc(db, `artifacts/${APP_ID_FOR_FIRESTORE}/users/${userId}/daysOff`, d);
            const day = new Date(d + 'T12:00:00Z').getUTCDay();
            if (daysOff[d]) { await deleteDoc(docRef); // If it exists, delete (revert to default)
            } else { await setDoc(docRef, { isWorkDay: day === 0 || day === 6 }); // If it doesn't, create it
            }
        }

        /**
         * Renders the main statistics chart.
         */
        function renderChart() {
            if (chartInstance) { chartInstance.destroy();
            }
            const chartType = document.getElementById('chartTypeSelect').value;
            const activeViewBtn = document.querySelector('#chartViewControls .view-btn.active') || document.getElementById('viewDay');
            const viewType = activeViewBtn.id.replace('view', '').toLowerCase();
            
            // Add info tooltips for specific charts
            const infoContainer = document.getElementById('chartInfoIconContainer');
            infoContainer.innerHTML = '';
            if(chartType === 'minsPerInterruption') {
                infoContainer.innerHTML = `<div class="info-tooltip-container">
                    <i class="fa-solid fa-info-circle text-gray-400 cursor-pointer"></i>
                    <span class="info-tooltip-text">"Max" displays the longest uninterrupted focus time from timer sessions in the period.</span>
                </div>`;
            } else if (chartType === 'interruptionLikelihood') {
                 infoContainer.innerHTML = `<div class="info-tooltip-container">
                    <i class="fa-solid fa-info-circle text-gray-400 cursor-pointer"></i>
                    <span class="info-tooltip-text">This chart shows the average number of interruptions you experience for every 15 minutes of focus within each time interval. A higher value means you're more likely to be interrupted during that period.</span>
                 </div>`;
            }
            
            // Plugin to draw the 'Max' line for minsPerInterruption chart
            const maxLinePlugin = {
                id: 'maxLinePlugin',
                afterDraw: (chart) => {
                    const maxDatasetIndex = chart.data.datasets.findIndex(ds => ds.label === 'Max');
                    if (maxDatasetIndex === -1) return;

                    const ctx = chart.ctx;
                    const maxMeta = chart.getDatasetMeta(maxDatasetIndex);
                    const barMeta = chart.getDatasetMeta(0); 
                    if (!barMeta) return;
                    maxMeta.data.forEach((point, index) => {
                        const bar = barMeta.data[index];
                        if (bar) {
                            ctx.save();
                            ctx.beginPath();
                            ctx.moveTo(bar.x - bar.width / 2, point.y);
                            ctx.lineTo(bar.x + bar.width / 2, point.y);
                            ctx.lineWidth = 3;
                            ctx.strokeStyle = 'black';
                            ctx.stroke();
                            ctx.restore();
                        }
                    });
                }
            };

            // Get processed data for the chart
            const chartData = getChartData(viewType, chartType);
            const canvas = document.getElementById('timeChart');
            const ctx = canvas.getContext('2d');
            
            // Handle "No Data" case
            if (!chartData || (chartData.labels && chartData.labels.length === 0)) {
                chartInstance = new Chart(ctx, { type: 'bar', data: { labels: [], datasets: [] }, options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true } }, plugins: { legend: { display: false }, title: { display: true, text: 'No data available for this period.' }}}});
                return;
            }
            
            // Handle Bubble Chart (Reasons)
            if (chartType === 'reasonBubbleChart') {
                 chartInstance = new Chart(ctx, { type: 'bubble', data: { datasets: [{ label: 'Reasons for Low Quality', data: chartData.data, backgroundColor: 'rgba(239, 68, 68, 0.7)' }] }, options: { responsive: true, maintainAspectRatio: false, scales: { x: { display: false }, y: { display: false } }, plugins: { legend: { display: false }, tooltip: { callbacks: { label: c => `${chartData.labels[c.dataIndex]}: ${c.raw.rawCount} times` }}}, onClick: (evt) => { 
                 const points = chartInstance.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, true); if (points.length) { const firstPoint = points[0]; const label = chartData.labels[firstPoint.index]; openManageReasonModal(label);}}}});
            
            // Handle Bar/Line Charts
            } else {
                const { labels, datasets, unitSuffix, type, stacked, tooltipData } = chartData;
                
                // --- Start Y-Axis Refinement ---
                // Define base Y-axis options
                let yAxisOptions = {
                    type: 'linear',
                    stacked, 
                    beginAtZero: true,
                    ticks: {} // Callback will be added below
                };

                // Apply special formatting for time-based charts
                if (['avgDailyFocusTime', 'totalFocusTime', 'minsPerInterruption'].includes(chartType)) {
                    // Find the max data value (in seconds) to determine scale
                    const allData = datasets.flatMap(ds => ds.data).filter(val => val !== null && !isNaN(val));
                    const dataMax = allData.length > 0 ? Math.max(...allData) : 0;
                    const maxHours = dataMax / 3600;

                    let stepSizeInSeconds;

                    // Dynamically set stepSize for human-readable labels
                    if (maxHours <= 0.75) {      // Max is ~45 mins or less
                        stepSizeInSeconds = 900; // 15-minute steps
                    } else if (maxHours <= 2.5) { // Max is 2.5 hours or less
                        stepSizeInSeconds = 1800; // 0.5-hour (30 min) steps
                    } else if (maxHours <= 6) {   // Max is 6 hours or less
                        stepSizeInSeconds = 3600; // 1-hour steps
                    } else if (maxHours <= 12) {  // Max is 12 hours or less
                        stepSizeInSeconds = 7200; // 2-hour steps
                    } else if (maxHours <= 30) {  // Max is 30 hours or less
                        stepSizeInSeconds = 18000; // 5-hour steps
                    } else {
                        stepSizeInSeconds = 36000; // 10-hour steps
                    }

                    yAxisOptions.ticks.stepSize = stepSizeInSeconds;

                    // Set the scale's max to the next clean step
                    if (dataMax > 0 && stepSizeInSeconds > 0) {
                        yAxisOptions.max = Math.ceil(dataMax / stepSizeInSeconds) * stepSizeInSeconds;
                    }

                    // Define the callback for formatting these clean steps
                    yAxisOptions.ticks.callback = function(value) {
                        if (value === 0) return '0';

                        const totalMinutes = value / 60;
                        const totalHours = value / 3600;

                        // Use the scale's max value (this.max) to decide formatting
                        const scaleMaxHours = this.max / 3600;

                        if (scaleMaxHours < 1) { 
                            // If the whole scale is less than 1 hour, show minutes
                            return `${Math.round(totalMinutes)}m`;
                        } else {
                            // Otherwise, show hours. parseFloat strips trailing .0 (e.g., 1.0 -> 1)
                            return `${parseFloat(totalHours.toFixed(1))}h`;
                        }
                    };

                } else if (chartType === 'interruptionLikelihood') {
                    // Preserve specific callback for interruptionLikelihood
                    yAxisOptions.ticks.callback = function(value) {
                        return value.toFixed(1);
                    };
                } else {
                    // Default callback for other charts (e.g., avgQuality)
                    yAxisOptions.ticks.callback = function(value) {
                        return `${value.toFixed(1)}${unitSuffix}`;
                    };
                }
                // --- End Y-Axis Refinement ---

                chartInstance = new Chart(ctx, { type: type || 'bar', data: { labels, datasets }, 
                plugins: chartType === 'minsPerInterruption' ? [maxLinePlugin] : [],
                options: { responsive: true, maintainAspectRatio: false, interaction: { mode: 'index', intersect: false },
                scales: { 
                    x: { stacked }, 
                    y: yAxisOptions // Use the dynamically generated yAxisOptions
                }, 
                plugins: { 
                    legend: { 
                        labels: { 
                            generateLabels: function(chart) {
                                const originalLabels = Chart.defaults.plugins.legend.labels.generateLabels(chart);
                                originalLabels.forEach(label => {
                                    if (label.text === 'Max') {
                                        label.fillStyle = 'rgba(0,0,0,0)';
                                        label.strokeStyle = 'black';
                                        label.lineWidth = 2;
                                    }
                                });
                                return originalLabels;
                            }
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                if (chartType === 'completedSessions' && tooltipData) {
                                    const data = tooltipData[context.dataIndex];
                                    return `${context.dataset.label}: ${context.parsed.y.toFixed(0)}% (${data.completed}/${data.goal})`;
                                }
                                let val = context.raw;
                                if (val === null || isNaN(val)) return '';

                                if (chartType === 'interruptionLikelihood') {
                                    return `${context.dataset.label}: ${val.toFixed(2)} avg interruptions`;
                                }
                                
                                // Format time-based tooltips
                                if (['avgDailyFocusTime', 'totalFocusTime', 'minsPerInterruption'].includes(chartType)) {
                                    const totalMinutes = val / 60;
                                    if (totalMinutes >= 60) {
                                        const hours = Math.floor(totalMinutes / 60);
                                        const minutes = Math.floor(totalMinutes % 60);
                                        return `${context.dataset.label}: ${hours}h ${minutes}m`;
                                    }
                                    return `${context.dataset.label}: ${Math.floor(totalMinutes)}m`;
                                }
                                return `${context.dataset.label}: ${context.parsed.y.toFixed(1)}${unitSuffix}`;
                            }
                        }
                    }
                }}});
            }
        }
        
        /**
         * Calculates and prepares all data for chart rendering.
         * @param {string} viewType - 'day', 'week', 'month', or 'year'.
         * @param {string} chartType - The selected chart type (e.g., 'totalFocusTime').
         * @returns {object} The data object for Chart.js.
         */
        function getChartData(viewType, chartType) {
            let { labels, ranges } = getPeriods(viewType);

            // Find the first date with any data to avoid empty chart prefixes
            let firstTrackedDate = null;
            const allDates = Object.keys(focusedTimeData).sort();
            if (allDates.length > 0) {
                firstTrackedDate = new Date(allDates[0] + 'T00:00:00');
            }

            // For MPI chart, start from the first *interruption*
            if (chartType === 'minsPerInterruption') {
                let firstInterruptionDate = null;
                for (const date of allDates) {
                    const sessions = focusedTimeData[date]?.sessions || [];
                    if (sessions.some(s => s.interruptions && s.interruptions.length > 0)) {
                        firstInterruptionDate = new Date(date + 'T00:00:00');
                        break;
                    }
                }
                if (firstInterruptionDate) {
                    firstTrackedDate = firstInterruptionDate;
                } else {
                    return { labels: [], datasets: [] }; // No interruptions, empty chart
                }
            }

            // Filter out ranges that are entirely before the first tracked date
            if (firstTrackedDate) {
                const filtered = ranges.map((r, i) => ({r, l: labels[i]})).filter(item => item.r.e >= firstTrackedDate);
                ranges = filtered.map(item => item.r);
                labels = filtered.map(item => item.l);
            }

            /**
             * Generates date ranges and labels for the chart's x-axis.
             */
            function getPeriods(vType) {
                const periods = { day: 7, week: 12, month: 12, year: 5 };
                const num = periods[vType];
                let labels = [], ranges = [];
                let today = new Date();
                if (vType === 'day') {
                    // Get the last `num` *work days*
                    let workDays = [];
                    let dayIterator = new Date(); dayIterator.setHours(12,0,0,0);
                    for (let i = 0; workDays.length < num && i < 365; i++) {
                        const cur = new Date(dayIterator);
                        cur.setDate(dayIterator.getDate() - i); const str = cur.toISOString().slice(0, 10);
                        if (!isDayOff(str)) { workDays.unshift(cur);
                        }
                    }
                    labels = workDays.map(d => d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }));
                    ranges = workDays.map(d => ({s: d, e: d}));
                } else {
                    // Get last `num` weeks, months, or years
                    let allRanges = [];
                    let todayForRanges = new Date(); todayForRanges.setHours(12,0,0,0);
                    for (let i = num - 1; i >= 0; i--) {
                        let s, e, label;
                        if (vType === 'week') {
                            s = new Date(todayForRanges);
                            s.setHours(0, 0, 0, 0); s.setDate(todayForRanges.getDate() - (i * 7) - todayForRanges.getDay());
                            e = new Date(s); e.setDate(s.getDate() + 6);
                            label = `W of ${s.toLocaleDateString('en-US',{month:'short',day:'numeric'})}`;
                        } else if (vType === 'month') {
                            s = new Date(todayForRanges.getFullYear(), todayForRanges.getMonth() - i, 1);
                            e = new Date(todayForRanges.getFullYear(), todayForRanges.getMonth() - i + 1, 0);
                            label = s.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                        } else {
                            const y = todayForRanges.getFullYear() - i;
                            s = new Date(y, 0, 1); e = new Date(y, 11, 31); label = y.toString();
                        }
                        allRanges.push({ s, e, label });
                    }
                    labels = allRanges.map(r => r.label);
                    ranges = allRanges.map(r => ({s: r.s, e: r.e}));
                }
                return { labels, ranges };
            };
            
            /**
             * Calculates a linear regression trend line for a dataset.
             */
            const calculateTrend = (data) => {
                const validPoints = data.map((y, x) => ({ x, y })).filter(p => p.y !== null && p.y >= 0 && Number.isFinite(p.y));

                if (validPoints.length === 1) {
                    const trendValue = validPoints[0].y;
                    return data.map(d => d !== null ? trendValue : null);
                }

                if (validPoints.length < 2) return Array(data.length).fill(null);
                
                let sX=0, sY=0, sXY=0, sXX=0, n=validPoints.length;
                validPoints.forEach(p => { sX += p.x; sY += p.y; sXY += p.x*p.y; sXX += p.x*p.x; });
                const m = (n*sXX - sX*sX) !== 0 ? (n*sXY - sX*sY) / (n*sXX - sX*sX) : 0;
                const b = (sY/n) - (m*sX/n);
                return data.map((val, x) => {
                    if (val === null) return null;
                    const trendVal = m * x + b;
                    return trendVal >= 0 ? trendVal : null;
                });
            };

            // --- Chart-Specific Data Processing ---

            // Reason Bubble Chart
            if (chartType === 'reasonBubbleChart') {
                const stats = {};
                Object.values(focusedTimeData).flatMap(d => d.sessions || []).forEach(s => {
                    if (s.reason) { if (!stats[s.reason]) { stats[s.reason] = { count: 0 }; } stats[s.reason].count++; }
                });
                const labels = Object.keys(stats);
                const data = labels.map(r => ({ x: Math.random() * 100, y: Math.random() * 100, r: stats[r].count * 4 + 5, rawCount: stats[r].count }));
                return { labels, data };
            }
            
            // Interruption Likelihood (Comparison) Chart
             if (chartType === 'interruptionLikelihood') {
                try {
                    const range1Start = document.getElementById('range1Start').value;
                    const range1End = document.getElementById('range1End').value;
                    if (!range1Start || !range1End) return { labels: [], datasets: [] };
                    
                    const binSize = 15 * 60; // Fixed 15-minute bins

                    const isComparing = document.getElementById('compareToggle').checked;
                    const range2Start = document.getElementById('range2Start').value;
                    const range2End = document.getElementById('range2End').value;
                    if (isComparing && (!range2Start || !range2End)) return { labels: [], datasets: [] };
                    const period1Label = `${new Date(range1Start+'T12:00').toLocaleDateString('default', {month:'short', day:'numeric'})} - ${new Date(range1End+'T12:00').toLocaleDateString('default', {month:'short', day:'numeric'})}`;
                    
                    const getSessionsInRange = (start, end) => {
                        const sessions = [];
                        for (let d = new Date(start + 'T12:00'); d <= new Date(end + 'T12:00'); d.setDate(d.getDate() + 1)) {
                            const dStr = d.toISOString().slice(0, 10);
                            const daySessions = focusedTimeData[dStr]?.sessions || [];
                            daySessions.forEach(s => {
                                if (s.duration > 0 && !s.isManual) { // Only include non-manual sessions
                                    sessions.push(s);
                                }
                            });
                        }
                        return sessions;
                    };

                    const calculateLikelihood = (sessions) => {
                        if (sessions.length === 0) return { bins: {}, labels: [] };

                        const allDurations = sessions.map(s => s.duration);
                        const maxTime = Math.max(...allDurations, 15 * 60);
                        const numBins = Math.ceil(maxTime / binSize);
                        
                        let bins = {};
                        
                        // Initialize bins
                        for (let i = 0; i < numBins; i++) {
                            const binStart = i * binSize;
                            const binEnd = (i + 1) * binSize;
                            const formatLabelPart = (seconds) => {
                                const hours = seconds / 3600;
                                if (Number.isInteger(hours)) return `${hours}h`;
                                if (seconds % 3600 !== 0 && hours > 1) return `${parseFloat(hours.toFixed(2))}h`;
                                return `${seconds / 60}m`;
                            };
                            const key = `${formatLabelPart(binStart)}-${formatLabelPart(binEnd)}`;
                            bins[key] = { interruptions: 0, totalTime: 0 };
                        }
                        
                        const parseKeyForSort = (key) => {
                            const startPart = key.split('-')[0];
                            const val = parseFloat(startPart);
                            return startPart.includes('h') ? val * 3600 : val * 60;
                        };
                        const sortedBinLabels = Object.keys(bins).sort((a,b) => parseKeyForSort(a) - parseKeyForSort(b));

                        sessions.forEach(session => {
                            // Tally total time in each bin
                            let remainingDuration = session.duration;
                            for (let i = 0; i < sortedBinLabels.length; i++) {
                                if (remainingDuration <= 0) break;
                                const timeInThisBin = Math.min(remainingDuration, binSize);
                                bins[sortedBinLabels[i]].totalTime += timeInThisBin;
                                remainingDuration -= timeInThisBin;
                            }

                            // Tally interruptions in each bin
                            (session.interruptions || []).forEach(interruption => {
                                const timestamp = typeof interruption === 'number' ? interruption : interruption.time;
                                const binIndex = Math.floor(timestamp / binSize);
                                if (binIndex < sortedBinLabels.length) {
                                    bins[sortedBinLabels[binIndex]].interruptions++;
                                }
                            });
                        });
                        return { bins, labels: sortedBinLabels };
                    };
                    
                    const { bins: bins1, labels: labels1 } = calculateLikelihood(getSessionsInRange(range1Start, range1End));
                    
                    let datasets = [];
                    let allLabels = [...labels1];

                    const data1 = allLabels.map(key => {
                        const bin = bins1[key];
                        if (!bin || bin.totalTime === 0) return 0;
                        return (bin.interruptions / (bin.totalTime / binSize));
                    });

                    datasets.push({ label: period1Label, data: data1, type: 'line', borderColor: '#3B82F6', tension: 0.1 });
                    
                    if (isComparing) {
                        const period2Label = `${new Date(range2Start+'T12:00').toLocaleDateString('default', {month:'short', day:'numeric'})} - ${new Date(range2End+'T12:00').toLocaleDateString('default', {month:'short', day:'numeric'})}`;
                        const { bins: bins2, labels: labels2 } = calculateLikelihood(getSessionsInRange(range2Start, range2End));
                        
                        const parseKeyForSort = (key) => {
                             const startPart = key.split('-')[0];
                            const val = parseFloat(startPart);
                            return startPart.includes('h') ? val * 3600 : val * 60;
                        };
                        const allBinKeys = [...new Set([...allLabels, ...labels2])].sort((a,b) => parseKeyForSort(a) - parseKeyForSort(b));
                        allLabels = allBinKeys;
                        
                        const fullData1 = allLabels.map(key => {
                            const bin = bins1[key];
                            if (!bin || bin.totalTime === 0) return 0;
                            return (bin.interruptions / (bin.totalTime / binSize));
                        });

                        const data2 = allLabels.map(key => {
                            const bin = bins2[key];
                            if (!bin || bin.totalTime === 0) return 0;
                           return (bin.interruptions / (bin.totalTime / binSize));
                        });

                        datasets[0].data = fullData1;
                        datasets.push({ label: period2Label, data: data2, type: 'line', borderColor: '#EF4444', tension: 0.1 });
                    }

                    if (allLabels.length === 0) return { labels:[], datasets:[]};
                    return { labels: allLabels, datasets, unitSuffix: ' avg int.' };

                } catch(e) {
                     console.error("Error generating comparison chart:", e);
                     return { labels: [], datasets: [] };
                }
            }
            
            // Completed Sessions Chart
            if (chartType === 'completedSessions') {
                let filteredLabels = [], percentages = [], tooltipDataArr = [];
                labels.forEach((label, i) => {
                    const r = ranges[i];
                    let totalCompleted = 0, totalGoal = 0, workDays = 0;
                    for (let d = new Date(r.s); d <= r.e; d.setDate(d.getDate() + 1)) {
                        const dStr = d.toISOString().slice(0, 10);
                        if (!isDayOff(dStr)) {
                            workDays++;
                            totalGoal += goals[dStr]?.scheduledSessionsGoal ?? 0;
                            totalCompleted += (focusedTimeData[dStr]?.sessions || []).filter(s => s.type === 'countdown').length;
                        }
                    }
                    // Only show periods where a goal was set
                    if (workDays > 0 && totalGoal > 0) {
                        filteredLabels.push(label);
                        percentages.push(Math.min(100, (totalCompleted / totalGoal) * 100));
                        tooltipDataArr.push({ completed: totalCompleted, goal: totalGoal });
                    }
                });
                if (filteredLabels.length === 0) return { labels: [], datasets:[]};
                
                let percentagesForTrend = [...percentages];
                if (viewType === 'day' && percentagesForTrend.length > 0) {
                    percentagesForTrend[percentagesForTrend.length - 1] = null; // Exclude today
                }
                const trendData = calculateTrend(percentagesForTrend);

                return { labels: filteredLabels, datasets: [
                    { label: '% Completed', data: percentages, backgroundColor: 'rgba(22, 163, 74, 0.7)', order: 2 },
                    { label: `Trend`, data: trendData, type: 'line', borderColor: '#EF4444', borderWidth: 2, pointRadius: 0, order: 1 }
                ], unitSuffix: '%', tooltipData: tooltipDataArr };
            }

            // --- Generic Data Processor (for Time, Quality, MPI) ---
            const calcVal = (d, t) => {
                const sessions = focusedTimeData[d]?.sessions || [];
                if (sessions.length === 0) return { value: 0, hasData: false };
                if (t === 'minsPerInterruption') {
                    const relevantSessions = sessions.filter(s => !s.isManual || (s.isManual && s.interruptions != null));
                    if (relevantSessions.length === 0) return { value: 0, hasData: false };
                    const duration = relevantSessions.reduce((sum, i) => sum + i.duration, 0);
                    const interruptions = relevantSessions.reduce((sum, i) => sum + ((i.interruptions?.length || 0)), 0);
                    return { value: duration > 0 ? duration / (interruptions + 1) : 0, hasData: true };
                }
                if (t === 'avgQuality') {
                    const r = sessions.filter(i => i.quality != null);
                    return { value: r.length > 0 ? r.reduce((sum, i) => sum + i.quality, 0) / r.length : 0, hasData: r.length > 0 };
                }
                // Default: totalFocusTime, avgDailyFocusTime
                return { value: sessions.reduce((sum, i) => sum + i.duration, 0), hasData: true };
            };

            // Aggregate data based on ranges
            let actualData = [], maxFocusData = [], filteredLabels = [], filteredRanges = [];
            ranges.forEach((r, i) => {
                let hasPeriodData = false;
                let workDaysInPeriod = 0;
                for (let d = new Date(r.s); d <= r.e; d.setDate(d.getDate() + 1)) {
                     const dStr = d.toISOString().slice(0, 10);
                     if (!isDayOff(dStr)) {
                         workDaysInPeriod++;
                     }
                     if ((focusedTimeData[dStr]?.sessions || []).length > 0 && calcVal(dStr, chartType).hasData) {
                         hasPeriodData = true;
                     }
                }
                
                // Only include periods that have data and at least one work day
                if ((hasPeriodData || ['avgDailyFocusTime', 'totalFocusTime'].includes(chartType)) && workDaysInPeriod > 0) {
                    filteredLabels.push(labels[i]);
                    filteredRanges.push(r);
                }
            });
            
            // Calculate final values for each filtered range
            filteredRanges.forEach(r => {
                let val = 0, workDays = 0, maxFocus = 0;
                const today = new Date();
                today.setHours(23, 59, 59, 999);
                const loopEndDate = r.e > today ? today : r.e;
                const loopStartDate = firstTrackedDate && r.s < firstTrackedDate ? firstTrackedDate : r.s;

                for (let d = new Date(loopStartDate); d <= loopEndDate; d.setDate(d.getDate() + 1)) {
                    const dStr = d.toISOString().slice(0, 10);
                    if (!isDayOff(dStr)) {
                        val += calcVal(dStr, chartType).value;
                        workDays++;
                        if (chartType === 'minsPerInterruption') maxFocus = Math.max(maxFocus, calculateMaxUninterruptedFocus(dStr, true));
                    }
                }
                const isAvg = viewType !== 'day' && chartType === 'avgDailyFocusTime';
                actualData.push(isAvg && workDays > 0 ? val / workDays : val);
                maxFocusData.push(maxFocus);
            });
            
            if (filteredLabels.length === 0) return { labels: [], datasets:[]};

            let unitSuffix = '⭐';
            if (['avgDailyFocusTime', 'totalFocusTime', 'minsPerInterruption'].includes(chartType)) { unitSuffix = 's'; // Seconds, will be formatted by callback
            }

            // Calculate trend line
            let trendData;
            let dataForTrend = [...actualData];
            
            // Exclude "today" or "current period" from trend calculation
            if ((chartType === 'avgDailyFocusTime' || chartType === 'totalFocusTime') && dataForTrend.length > 0) {
                if (viewType === 'day') {
                     dataForTrend[dataForTrend.length - 1] = null;
                } else {
                    const todayForTrend = new Date();
                    todayForTrend.setHours(0, 0, 0, 0);
                    const lastRange = filteredRanges[filteredRanges.length - 1];
                    const isCurrentPeriod = todayForTrend >= lastRange.s && todayForTrend <= lastRange.e;
                    if (isCurrentPeriod) {
                        dataForTrend[dataForTrend.length - 1] = null;
                    }
                }
            }
            trendData = calculateTrend(dataForTrend);
            
            // Prepare datasets for Chart.js
            const maxTrend = calculateTrend(maxFocusData);
            let datasets;
             if (chartType === 'minsPerInterruption') {
                datasets = [
                    { label: `Avg`, data: actualData, backgroundColor: 'rgba(59, 130, 246, 0.7)', order: 4 },
                    { label: `Max`, data: maxFocusData, type: 'line', radius: 5, pointHitRadius: 20, backgroundColor: 'transparent', borderColor: 'transparent', order: 2 },
                    { label: `Trend`, data: trendData, type: 'line', borderColor: '#EF4444', borderWidth: 2, pointRadius: 0, order: 3 },
                    { label: `Max Trend`, data: maxTrend, type: 'line', borderColor: 'grey', borderDash: [5, 5], borderWidth: 2, pointRadius: 0, order: 1 }
                ];
            } else {
                datasets = [
                    { label: `Actual`, data: actualData, backgroundColor: 'rgba(59, 130, 246, 0.7)', order: 2 },
                    { label: `Trend`, data: trendData, type: 'line', borderColor: '#EF4444', borderWidth: 2, pointRadius: 0, order: 1 }
                ];
            }
            
            return { labels: filteredLabels, datasets, unitSuffix, type: 'bar', stacked: false };
        }
        
        /**
         * Renders the session log.
         */
        function renderLog() {
            const logDiv = document.getElementById('logEntries'), moreBtn = document.getElementById('showMoreLogBtn');
            logDiv.innerHTML = ''; const entries = Object.entries(focusedTimeData).flatMap(([d, data]) => (data.sessions || []).map(s => ({...s, date: d }))).sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            if (entries.length === 0) { logDiv.innerHTML = '<p class="text-center text-gray-500">No entries yet.</p>'; moreBtn.classList.add('hidden'); return;
            }
            const toShow = showAllLogEntries ? entries : entries.slice(0, 5);
            toShow.forEach(e => {
                const s = e.quality ? Array(Math.round(e.quality)).fill('<i class="fa-solid fa-star log-star"></i>').join('') : 'No rating';
                const interruptionCount = e.interruptions?.length || 0;
                const logItem = document.createElement('div'); logItem.className = 'log-entry-item';
                logItem.innerHTML = `<span>${e.date} at ${new Date(e.timestamp).toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'})}</span><span class="flex items-center gap-2">${formatTimer(e.duration)} (${interruptionCount} int.) <span class="text-yellow-500 flex items-center">${s}</span></span><div class="space-x-2"><button class="text-sm text-blue-600 hover:underline edit-btn" data-date="${e.date}" data-session-id="${e.id}">Edit</button><button class="text-sm text-red-600 hover:underline delete-btn" data-date="${e.date}" data-session-id="${e.id}">Delete</button></div>`;
                logDiv.appendChild(logItem);
            });
            moreBtn.style.display = entries.length > 5 ? 'block' : 'none'; moreBtn.textContent = showAllLogEntries ? 'Show Less' : 'Show More';
            // Add event listeners to new buttons
            document.querySelectorAll('.edit-btn').forEach(b => b.addEventListener('click', e => editSessionPrompt(e.target.dataset.date, e.target.dataset.sessionId)));
            document.querySelectorAll('.delete-btn').forEach(b => b.addEventListener('click', e => deleteSession(e.target.dataset.date, e.target.dataset.sessionId)));
        }
        
        /**
         * Deletes a session from Firestore.
         * @param {string} date - The date string (YYYY-MM-DD) of the session.
         * @param {string} sessionId - The ID of the session to delete.
         */
        async function deleteSession(date, sessionId) {
            if (!(await showConfirm('Delete this entry?'))) return;
            const updated = focusedTimeData[date].sessions.filter(s => s.id !== sessionId);
            try {
                const docRef = doc(db, `artifacts/${APP_ID_FOR_FIRESTORE}/users/${userId}/focusSessions`, date);
                if (updated.length > 0) { await updateDoc(docRef, { sessions: updated }); } else { await deleteDoc(docRef); // Delete doc if no sessions left
                }
                showMessage('Entry deleted.');
            } catch (e) { showMessage('Error deleting entry.'); }
        }
        
        /**
         * Opens the modal to edit a specific log entry.
         * @param {string} date - The date string (YYYY-MM-DD) of the session.
         * @param {string} sessionId - The ID of the session to edit.
         */
        function editSessionPrompt(date, sessionId) {
            const session = focusedTimeData[date]?.sessions.find(s => s.id === sessionId);
            if (!session) return;
            const modal = document.getElementById('editLogModal');
            const h = Math.floor(session.duration/3600), m = Math.floor((session.duration%3600)/60), s = session.duration%60;
            const interruptionCount = session.interruptions?.length || 0;
            const isManualSession = session.isManual;
            // Disable interruptions input for non-manual sessions
            const interruptionsInputHTML = isManualSession
                ? `<div class="mt-2"><label>Interruptions</label><input type="number" id="editInterruptions" value="${interruptionCount}" class="w-full p-2 border rounded"></div>`
                : `<div class="mt-2"><label>Interruptions (from timer)</label><input type="number" id="editInterruptions" value="${interruptionCount}" class="w-full p-2 border rounded bg-gray-100" disabled></div>`;
            modal.innerHTML = `<div class="modal-content"><h3 class="text-xl font-bold mb-4">Edit Entry</h3><div class="grid grid-cols-3 gap-2"><div><label>H</label><input type="number" id="editHours" value="${h}" class="w-full p-2 border rounded"></div><div><label>M</label><input type="number" id="editMinutes" value="${m}" class="w-full p-2 border rounded"></div><div><label>S</label><input type="number" id="editSeconds" value="${s}" class="w-full p-2 border rounded"></div></div>${interruptionsInputHTML}<div class="mt-2"><label>Quality</label><div class="star-rating flex justify-center mt-1" data-rating="${session.quality||0}" id="editStarRating"><i class="fa-solid fa-star" data-value="1"></i><i class="fa-solid fa-star" data-value="2"></i><i class="fa-solid fa-star" data-value="3"></i><i class="fa-solid fa-star" data-value="4"></i><i class="fa-solid fa-star" data-value="5"></i></div></div><div class="mt-4 flex justify-end space-x-2"><button id="cancelEditBtn" class="btn bg-gray-300">Cancel</button><button id="saveEditBtn" class="btn btn-blue">Save</button></div></div>`;
            modal.style.display = 'flex';
            
            // Setup star rating for the edit modal
            const starContainer = modal.querySelector('#editStarRating');
            const stars = starContainer.querySelectorAll('.fa-star');
            const initialRating = session.quality || 0;
            stars.forEach(star => star.classList.toggle('selected', star.dataset.value <= initialRating));
            setupStarRating(starContainer);

            // Save button logic
            document.getElementById('saveEditBtn').onclick = () => {
                const newDur = (parseInt(document.getElementById('editHours').value)*3600) + (parseInt(document.getElementById('editMinutes').value)*60) + parseInt(document.getElementById('editSeconds').value);
                const newQuality = parseInt(starContainer.dataset.rating) || null;
                let updatedInterruptions;

                if (session.isManual) {
                    // For manual sessions, just update the count
                    const newInt = parseInt(document.getElementById('editInterruptions').value);
                    updatedInterruptions = Array(newInt >= 0 ? newInt : 0).fill({ time: 0, penalty: 0 }); // Create dummy array
                } else {
                    // For timer sessions, filter out interruptions that are beyond the new duration
                    const originalInterruptions = session.interruptions || [];
                    updatedInterruptions = originalInterruptions.filter(i => i.time <= newDur);
                }
                
                updateSession(date, sessionId, {duration: newDur, interruptions: updatedInterruptions, quality: newQuality});
                modal.style.display = 'none';
            };
            document.getElementById('cancelEditBtn').onclick = () => modal.style.display = 'none';
        }

        /**
         * Updates a specific session in Firestore.
         * @param {string} date - The date string (YYYY-MM-DD) of the session.
         * @param {string} id - The ID of the session to update.
         * @param {object} updatedFields - The fields to merge into the session object.
         */
        async function updateSession(date, id, updatedFields) {
            const updated = focusedTimeData[date].sessions.map(s => s.id === id ? { ...s, ...updatedFields } : s);
            try {
                await updateDoc(doc(db, `artifacts/${APP_ID_FOR_FIRESTORE}/users/${userId}/focusSessions`, date), { sessions: updated });
                showMessage('Updated.');
            } catch (e) { showMessage('Error updating.'); }
        }
        
        /**
         * Sets up all application event listeners.
         */
        function setupEventListeners() {
            // --- Auth ---
            const authEmail=document.getElementById('authEmail'), authPassword=document.getElementById('authPassword'), authError=document.getElementById('authErrorMessage');
            document.getElementById('signInBtn').addEventListener('click', () => { authError.textContent = ''; signInWithEmailAndPassword(auth, authEmail.value, authPassword.value).catch(e => authError.textContent = e.message); });
            document.getElementById('createAccountBtn').addEventListener('click', () => { authError.textContent = ''; createUserWithEmailAndPassword(auth, authEmail.value, authPassword.value).catch(e => authError.textContent = e.message); });
            document.getElementById('anonymousSignInBtn').addEventListener('click', () => { authError.textContent = ''; signInAnonymously(auth).catch(e => authError.textContent = e.message); });
            
            // --- Timer ---
            document.getElementById('togglePauseBtn').addEventListener('click', toggleTimer);
            document.getElementById('endFocusBtn').addEventListener('click', () => handleEndFocus(false));
            document.getElementById('logInterruptionBtn').addEventListener('click', () => {
                const penaltyInput = document.getElementById('penaltyMinutesInput');
                const label = document.querySelector('label[for="penaltyMinutesInput"]');
                // Calculate max penalty based on time since last interruption/start
                const elapsedSecondsSinceLastEvent = running && lastPenaltyResetTime ? (Date.now() - lastPenaltyResetTime) / 1000 : 0;
                const maxMinutes = Math.floor(elapsedSecondsSinceLastEvent / 60);
                penaltyInput.max = maxMinutes;
                label.textContent = `Penalty Minutes (max: ${maxMinutes})`;
                
                document.getElementById('logInterruptionModal').style.display = 'flex';
            });
            document.querySelectorAll('.timer-mode-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    if (running) { showMessage("Please end the current session before switching modes."); return; }
                    document.querySelectorAll('.timer-mode-btn').forEach(b => b.classList.remove('active')); e.currentTarget.classList.add('active');
                    currentTimerMode = e.currentTarget.id === 'stopwatchModeBtn' ? 'stopwatch' : 'countdown';
                    document.getElementById('timerModeDescription').textContent = currentTimerMode === 'stopwatch' ? 'Stopwatch' : 'Countdown';
                    resetTimerState(); renderChart(); 
                });
            });

            // --- Toggles ---
            document.getElementById('notificationToggle').addEventListener('change', e => { notificationsEnabled = e.target.checked; localStorage.setItem('notificationToggleState', String(e.target.checked)); if(e.target.checked) { Notification.requestPermission(); } });
            document.getElementById('focusMusicToggle').addEventListener('change', e => { focusMusicEnabled = e.target.checked; localStorage.setItem('focusMusicToggleState', String(e.target.checked)); });
            
            // --- Chart Controls ---
            document.querySelectorAll('#chartViewControls .view-btn').forEach(b => b.addEventListener('click', e => { document.querySelectorAll('#chartViewControls .view-btn').forEach(i => i.classList.remove('active')); e.currentTarget.classList.add('active'); renderChart(); }));
            document.getElementById('chartTypeSelect').addEventListener('change', (e) => {
                const chartType = e.target.value;
                const defaultControls = document.getElementById('chartViewControls');
                const comparisonControls = document.getElementById('comparisonControls');
                if (chartType === 'interruptionLikelihood') {
                    defaultControls.classList.add('hidden');
                    comparisonControls.classList.remove('hidden');
                    setupComparisonControls();
                } else {
                    defaultControls.classList.remove('hidden');
                    comparisonControls.classList.add('hidden');
                }
                renderChart();
            });
            // Comparison chart controls
            ['range1Start', 'range1End', 'range2Start', 'range2End', 'compareToggle'].forEach(id => {
                document.getElementById(id).addEventListener('change', () => {
                    if (id === 'compareToggle') {
                        document.getElementById('period2Container').classList.toggle('hidden', !document.getElementById('compareToggle').checked);
                    }
                    renderChart();
                });
            });

            // --- Log & Calendar ---
            document.getElementById('showMoreLogBtn').addEventListener('click', () => { showAllLogEntries = !showAllLogEntries; renderLog(); });
            document.getElementById('addEntryBtn').addEventListener('click', async () => {
                const d = document.getElementById('newEntryDate').value, h = parseInt(document.getElementById('newEntryHours').value)||0, m = parseInt(document.getElementById('newEntryMinutes').value)||0;
                const intVal = document.getElementById('newEntryInterruptions').value;
                const interruptions = intVal !== '' && Number(intVal) >= 0 ? Array(parseInt(intVal)).fill({ time: 0, penalty: 0 }) : null;
                const q = parseInt(document.getElementById('newEntryStarRating').dataset.rating) || null;
                if (!d || (h === 0 && m === 0)) { showMessage("Date and duration required."); return; }
                
                const totalEntriesBeforeAdding = Object.values(focusedTimeData).reduce((sum, day) => sum + (day.sessions?.length || 0), 0);
                const isFirstEver = totalEntriesBeforeAdding === 0;

                const newS = { id: crypto.randomUUID(), duration: (h*3600)+(m*60), interruptions, quality: q, timestamp: new Date(d+'T12:00:00').toISOString(), type: 'stopwatch', isManual: true };
                
                // Optimistic update
                if (!focusedTimeData[d]) focusedTimeData[d] = { sessions: [] };
                focusedTimeData[d].sessions.push(newS);
                debounceUpdateUI();

                try {
                    const docRef = doc(db, `artifacts/${APP_ID_FOR_FIRESTORE}/users/${userId}/focusSessions`, d);
                    const docSnap = await getDoc(docRef);
                    const existing = docSnap.exists() && docSnap.data().sessions ? docSnap.data().sessions : [];
                    await setDoc(docRef, { sessions: [...existing, newS] }, { merge: true });

                    // If it's the user's first entry, auto-mark past weekdays as days off
                    if (isFirstEver) {
                        const firstEntryDate = new Date(d + 'T12:00:00Z');
                        const batch = writeBatch(db);
                        for (let i = 1; i <= 365; i++) { // Go back up to a year
                            let pastDate = new Date(firstEntryDate);
                            pastDate.setDate(firstEntryDate.getDate() - i);
                            const dateStr = pastDate.toISOString().slice(0, 10);
                            const dayOfWeek = pastDate.getUTCDay();
                            if ((dayOfWeek !== 0 && dayOfWeek !== 6) && !daysOff[dateStr]) { // Is a weekday and not already set
                                const dayOffDocRef = doc(db, `artifacts/${APP_ID_FOR_FIRESTORE}/users/${userId}/daysOff`, dateStr);
                                batch.set(dayOffDocRef, { isWorkDay: false });
                            }
                        }
                        await batch.commit();
                        showMessage("Entry added! Past weekdays have been marked as days off.");
                    } else {
                        showMessage("Entry added!");
                    }
                } catch (e) {
                    showMessage("Error adding entry.");
                    // Revert optimistic update on failure
                    focusedTimeData[d].sessions = focusedTimeData[d].sessions.filter(s => s.id !== newS.id);
                    debounceUpdateUI();
                }
            });
            document.getElementById('prevMonthBtn').addEventListener('click', () => { calendarDate.setMonth(calendarDate.getMonth() - 1); renderCalendar(); });
            document.getElementById('nextMonthBtn').addEventListener('click', () => { calendarDate.setMonth(calendarDate.getMonth() + 1); renderCalendar(); });
            setupStarRating(document.getElementById('newEntryStarRating'));

            // --- Goals ---
            document.getElementById('openGoalsModalBtn').addEventListener('click', openGoalsModal);
            document.getElementById('saveGoalsBtn').addEventListener('click', saveGoals);
            ['todayFocusGoal', 'scheduledSessionsGoal', 'interruptionGoal'].forEach(id => {
                document.getElementById(id).addEventListener('input', validateGoalInput);
            });
            
            // --- Modal Close Buttons ---
            document.querySelectorAll('.modal .close-button, .modal [id^=cancel], .modal [id=modalOkBtn]').forEach(b => b.addEventListener('click', e => e.currentTarget.closest('.modal').style.display = 'none'));
            
            // --- Countdown Modals ---
            document.getElementById('closeMedalModalBtn').addEventListener('click', () => {
                clearInterval(overtimeInterval); const overtimeMs = overtimeStartTime ? Date.now() - overtimeStartTime : 0;
                const addOvertime = document.getElementById('addOvertimeCheckbox').checked;
                const finalDuration = sessionDataForReflection.duration + (addOvertime ? overtimeMs : 0);
                document.getElementById('medalModal').style.display = 'none';
                
                const totalSessionDuration = sessionDataForReflection.totalSessionDuration + (addOvertime ? overtimeMs : 0);
                showReflectionModal({ ...sessionDataForReflection, duration: finalDuration, totalSessionDuration });
            });
            const countdownMinutesInput = document.getElementById('countdownMinutes');
            const startCountdownBtn = document.getElementById('startCountdownBtn');
            const countdownErrorEl = document.getElementById('countdownError');

            function validateCountdownLength() {
                const m = parseInt(countdownMinutesInput.value);
                const minLength = userSettings.minSessionLength;
                if (minLength && minLength > 0 && m < minLength) {
                    countdownErrorEl.textContent = `It takes time to build focus. Try a session of at least ${minLength} minutes.`;
                    startCountdownBtn.disabled = true;
                } else {
                    countdownErrorEl.textContent = '';
                    startCountdownBtn.disabled = false;
                }
            }
            countdownMinutesInput.addEventListener('input', validateCountdownLength);
            startCountdownBtn.addEventListener('click', () => {
                const m = parseInt(countdownMinutesInput.value);
                if (startCountdownBtn.disabled) { validateCountdownLength(); return; }
                breakInterval = parseInt(document.getElementById('breakIntervalMinutes').value) * 60 || 0;
                if (m > 0) { 
                    countdownDuration = m * 60; 
                    document.getElementById('countdownModal').style.display = 'none'; 
                    startTimer(); 
                }
            });
            document.getElementById('earlyEndYesBtn').addEventListener('click', () => { document.getElementById('earlyEndModal').style.display = 'none'; showReflectionModal(sessionDataForReflection); });
            document.getElementById('earlyEndNoCountBtn').addEventListener('click', () => { document.getElementById('earlyEndModal').style.display = 'none'; showReflectionModal({ ...sessionDataForReflection, type: 'stopwatch' }); });
            document.getElementById('earlyEndNoDiscardBtn').addEventListener('click', () => { document.getElementById('earlyEndModal').style.display = 'none'; resetTimerState(); });

            // --- Interruption/Pause Modals ---
            document.getElementById('justPauseBtn').addEventListener('click', () => { 
                pauseTimer(); 
                document.getElementById('interruptionPromptModal').style.display = 'none'; 
                if (focusMusicEnabled) launchSpotify();
            });
            document.getElementById('logInterruptionFromPauseBtn').addEventListener('click', () => { 
                pauseTimer(); 
                document.getElementById('interruptionPromptModal').style.display = 'none'; 
                document.getElementById('logInterruptionModal').style.display = 'flex'; 
            });
            document.getElementById('cancelPauseBtn').addEventListener('click', () => { document.getElementById('interruptionPromptModal').style.display = 'none'; });
            document.getElementById('confirmLogInterruptionBtn').addEventListener('click', () => {
                const penaltyInput = document.getElementById('penaltyMinutesInput');
                const statusEl = document.getElementById('penaltyErrorStatus');
                statusEl.textContent = '';
                let penaltyMinutes = parseInt(penaltyInput.value) || 0;

                const maxPenalty = parseInt(penaltyInput.max);
                if (penaltyMinutes > maxPenalty) {
                    statusEl.textContent = `Penalty cannot exceed elapsed time (max: ${maxPenalty} min)`;
                    setTimeout(() => statusEl.textContent = '', 3000);
                    return;
                }

                const wallClockTimeAtInterruption = sessionAbsoluteStartTime ? (Date.now() - sessionAbsoluteStartTime) / 1000 : (accumulatedTime / 1000);
                const penaltySeconds = penaltyMinutes * 60;
                sessionInterruptionTimestamps.push({ time: wallClockTimeAtInterruption, penalty: penaltySeconds });
                lastPenaltyResetTime = Date.now(); // Reset penalty timer
                
                accumulatedTime -= penaltySeconds * 1000;
                
                document.getElementById('logInterruptionModal').style.display = 'none'; 
                penaltyInput.value = '5';
                updateTimerDisplay(); 
            });
            document.getElementById('continueSessionBtn').addEventListener('click', () => {
                document.getElementById('extendedBreakModal').style.display = 'none';
                startTimer();
            });
            document.getElementById('endCurrentSessionBtn').addEventListener('click', () => {
                document.getElementById('extendedBreakModal').style.display = 'none';
                handleEndFocus(false);
            });

            // --- Reflection Modals ---
            document.getElementById('confirmReflectionBtn').addEventListener('click', () => {
                const { duration, interruptions, pauseEvents, type } = sessionDataForReflection;
                const quality = parseInt(document.querySelector('#reflectionModal .star-rating').dataset.rating) || 0;
                document.getElementById('reflectionModal').style.display = 'none';
                if (quality <= 3) { showReasonModal(duration, interruptions, pauseEvents, quality, type); }
                else { 
                    stopAndSaveSession({ duration, interruptions, pauseEvents, quality, reason: null, type });
                    launchSpotify();
                }
            });
            document.getElementById('saveReasonBtn').addEventListener('click', async () => {
                const reason = document.getElementById('newReasonInput').value.trim();
                const { duration, interruptions, pauseEvents, quality, type } = sessionDataForReflection;
                await stopAndSaveSession({ duration, interruptions, pauseEvents, quality, reason: reason || 'Unspecified', type });
                document.getElementById('reasonModal').style.display = 'none'; document.getElementById('improvementModal').style.display = 'flex';
            });
            document.getElementById('finishReflectionBtn').addEventListener('click', () => {
                document.getElementById('improvementModal').style.display = 'none';
                launchSpotify();
            });
            document.getElementById('adhocReflectBtn').addEventListener('click', () => {
                document.getElementById('adhocReflectionModal').style.display = 'none';
                showReflectionModal(sessionDataForReflection);
            });
            document.getElementById('adhocSkipBtn').addEventListener('click', async () => {
                document.getElementById('adhocReflectionModal').style.display = 'none';
                await stopAndSaveSession({ ...sessionDataForReflection, quality: null, reason: null });
                launchSpotify();
            });
            
            // --- Manage Reason Modal ---
            document.getElementById('saveRenameBtn').addEventListener('click', handleReasonSave);
            document.getElementById('confirmReassignBtn').addEventListener('click', handleReasonReassign);
            document.getElementById('deleteReasonBtn').addEventListener('click', handleReasonDelete);
            
            // --- Settings Modal ---
            document.getElementById('settingsRitualText').addEventListener('input', () => debounceSaveSettings({ ritual: document.getElementById('settingsRitualText').value }, 'ritualSaveStatus'));
            document.getElementById('settingsSpotifyLink').addEventListener('input', () => debounceSaveSettings({ spotifyLink: document.getElementById('settingsSpotifyLink').value }, 'spotifySaveStatus'));
            document.getElementById('settingsMinSessionLength').addEventListener('input', () => debounceSaveSettings({ minSessionLength: parseInt(document.getElementById('settingsMinSessionLength').value) || null }, 'minSessionSaveStatus'));
            document.getElementById('addBreakActivityBtn').addEventListener('click', handleAddBreakActivity);
        }
        
        /**
         * Handles the end of a focus session (either by button or completion).
         * @param {boolean} completed - True if the session was a completed countdown.
         */
        function handleEndFocus(completed = false) {
            if (!running && accumulatedTime < 1000) { // Don't save if < 1 sec
                resetTimerState();
                return;
            }
            const wasRunning = running;
            if (wasRunning) {
                running = false;
                clearInterval(timerInterval);
                accumulatedTime += Date.now() - startTime;
            }

            // Finalize pause event
            if (!wasRunning && sessionPauseEvents.length > 0 && sessionPauseEvents[sessionPauseEvents.length - 1].end === null) {
                sessionPauseEvents[sessionPauseEvents.length - 1].end = (sessionAbsoluteStartTime ? (Date.now() - sessionAbsoluteStartTime) / 1000 : accumulatedTime / 1000);
            }
            const finalPauseEvents = sessionPauseEvents.filter(p => p.end !== null);
            const totalSessionMs = sessionAbsoluteStartTime ? (Date.now() - sessionAbsoluteStartTime) : accumulatedTime;
            
            // Store data for reflection
            sessionDataForReflection = { duration: accumulatedTime, totalSessionDuration: totalSessionMs, interruptions: sessionInterruptionTimestamps, pauseEvents: finalPauseEvents, type: currentTimerMode };
            
            // Route to correct modal
            if (currentTimerMode === 'countdown') {
                if (completed) {
                    document.getElementById('medalModal').style.display = 'flex';
                    startOvertimeTimer();
                } else {
                    document.getElementById('earlyEndModal').style.display = 'flex';
                }
            } else if (currentTimerMode === 'stopwatch') {
                document.getElementById('adhocReflectionModal').style.display = 'flex';
            }
        }

        /**
         * Opens the goals modal and pre-fills suggestions.
         */
        async function openGoalsModal() {
            // Suggest goals based on last 14 days of data
            const twoWeeksAgo = new Date(new Date().getTime() - 14*24*60*60*1000).toISOString().slice(0, 10);
            let totalMins = 0, workDays = new Set(), totalInt = 0;
            let countdownSessionsOnWorkdays = 0;
            Object.entries(focusedTimeData).forEach(([d, data]) => {
                if (d >= twoWeeksAgo && !isDayOff(d)) {
                    workDays.add(d);
                    (data.sessions || []).forEach(s => {
                        totalMins += s.duration / 60; totalInt += (s.interruptions?.length || 0);
                        if(s.type === 'countdown') countdownSessionsOnWorkdays++;
                    });
                }
            });
            const avgDaily = workDays.size > 0 ? totalMins / workDays.size : 30;
            const avgSess = workDays.size > 0 ? countdownSessionsOnWorkdays / workDays.size : 2;
            const avgMinsPerInt = totalInt > 0 ? totalMins / totalInt : (avgDaily > 0 ? avgDaily : 30);
            // Suggest slightly higher goals
            document.getElementById('todayFocusGoal').value = Math.round(avgDaily * 1.05);
            document.getElementById('scheduledSessionsGoal').value = Math.round(avgSess > 0 ? avgSess : 2);
            document.getElementById('interruptionGoal').value = Math.round(avgMinsPerInt * 1.05);
            document.getElementById('goalsModal').style.display = 'flex';
        }

        /**
         * Validates goal inputs (must be positive whole numbers).
         */
        function validateGoalInput(e) {
            const input = e.target;
            const errorEl = document.getElementById(`${input.id}Error`);
            const value = input.value;
            if (value === '' || (Number(value) >= 0 && !value.includes('.'))) {
                errorEl.textContent = '';
                return true;
            }
            errorEl.textContent = 'Please enter a whole positive number.';
            return false;
        }

        /**
         * Saves the goals for today to Firestore.
         */
        async function saveGoals() {
            const ids = ['todayFocusGoal', 'scheduledSessionsGoal', 'interruptionGoal'];
            let isValid = true;
            ids.forEach(id => {
                if (!validateGoalInput({target: document.getElementById(id)})) {
                    isValid = false;
                }
            });
            if (!isValid) return;

            const today = new Date().toISOString().slice(0, 10);
            const goalsData = {
                dailyGoal: parseInt(document.getElementById('todayFocusGoal').value) || 0,
                scheduledSessionsGoal: parseInt(document.getElementById('scheduledSessionsGoal').value) || 0,
                interruptionGoal: parseInt(document.getElementById('interruptionGoal').value) || 0
            };
            try {
                await setDoc(doc(db, `artifacts/${APP_ID_FOR_FIRESTORE}/users/${userId}/goals`, today), goalsData);
                document.getElementById('goalsModal').style.display = 'none';
            } catch (e) { console.error("Error saving goals:", e);
            }
        }
        
        /**
         * Disables the "Set Goals" button if goals are already set for today.
         */
        function checkAndManageGoalsUI() {
            const todayStr = new Date().toISOString().slice(0, 10);
            document.getElementById('openGoalsModalBtn').disabled = !!goals[todayStr];
        }

        /**
         * Generates a suggested star rating based on interruption count.
         */
        function getRatingSuggestionByInterruptionCount(interruptions, duration) {
            const interruptionCount = interruptions.length;
            const totalPenaltyMinutes = interruptions.reduce((sum, i) => sum + (i.penalty || 0), 0) / 60;

            // Check recent history for similar sessions
            const allRatedSessions = Object.values(focusedTimeData)
                .flatMap(d => d.sessions || [])
                .filter(s => s.quality != null)
                .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            
            const recent50 = allRatedSessions.slice(0, 50);

            if (recent50.length > 2) {
                const similarSessions = recent50.filter(s => (s.interruptions?.length || 0) === interruptionCount);
                if (similarSessions.length > 2) {
                    const totalQuality = similarSessions.reduce((sum, s) => sum + s.quality, 0);
                    return Math.round(totalQuality / similarSessions.length);
                }
            }

            // Fallback to formula
            const durationMinutes = duration / 1000 / 60;
            if (durationMinutes <= 0) {
                return Math.max(1, 5 - interruptionCount);
            }
            
            const disruptionScore = (interruptionCount * 1) + (totalPenaltyMinutes * 0.2);
            const normalizedDisruption = disruptionScore / (durationMinutes / 30);
            
            return Math.max(1, Math.round(5 - normalizedDisruption));
        }

        /**
         * Generates a suggested star rating based on historical Mins/Interruption.
         */
        function getHistoricalRatingSuggestion(duration, interruptions) {
            const interruptionCount = interruptions.length;
            if (duration <= 0) {
                return getRatingSuggestionByInterruptionCount(interruptions, duration);
            }
            
            const currentMpi = interruptionCount > 0 ? (duration / 1000 / 60) / interruptionCount : (duration / 1000 / 60);
            const allRatedSessions = Object.values(focusedTimeData)
                .flatMap(d => d.sessions || [])
                .filter(s => s.quality != null && s.duration > 0)
                .map(s => {
                    const ints = s.interruptions?.length || 0;
                    const mpi = ints > 0 ? (s.duration / 60) / ints : s.duration / 60; // in minutes
                    return { ...s, mpi };
                })
                .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            
            if (allRatedSessions.length < 5) {
                return getRatingSuggestionByInterruptionCount(interruptions, duration);
            }
            
            // Find sessions with similar MPI
            const similarSessions = allRatedSessions.filter(s => {
                if (currentMpi === 0) return s.mpi === 0;
                const similarity = Math.abs(s.mpi - currentMpi) / currentMpi;
                return similarity <= 0.25; // Within 25%
            });

            if (similarSessions.length > 2) {
                const totalQuality = similarSessions.reduce((sum, s) => sum + s.quality, 0);
                return Math.round(totalQuality / similarSessions.length);
            }
            
            // Fallback to simple interruption count logic
            return getRatingSuggestionByInterruptionCount(interruptions, duration);
        }

        /**
         * Shows the "Reason for Low Quality" modal.
         */
        function showReasonModal(duration, interruptions, pauseEvents, quality, type) {
            sessionDataForReflection = { duration, interruptions, pauseEvents, quality, type };
            const container = document.getElementById('pastReasonsContainer'); container.innerHTML = '';
            // Populate with existing reasons
            lowQualityReasons.forEach(r => {
                const b = document.createElement('button'); b.className = 'btn text-sm bg-gray-200 hover:bg-gray-300 text-gray-700 p-2';
                b.textContent = r; b.onclick = () => document.getElementById('newReasonInput').value = r; container.appendChild(b)
            });
            document.getElementById('reasonModal').style.display = 'flex';
        }

        /**
         * Sets up the date ranges for the comparison chart.
         */
        function setupComparisonControls() {
            document.getElementById('compareToggle').checked = false;
            document.getElementById('period2Container').classList.add('hidden');
            
            // Default "Period 1" to the last 20 work days
            let workDays = []; 
            let dayIterator = new Date(); 
            dayIterator.setHours(12,0,0,0);
            for (let i = 0; workDays.length < 20 && i < 365; i++) {
                const cur = new Date(dayIterator);
                cur.setDate(dayIterator.getDate() - i); 
                const str = cur.toISOString().slice(0, 10);
                if (!isDayOff(str)) { 
                    workDays.unshift(cur);
                }
            }
            if (workDays.length > 0) {
                const endDate = workDays[workDays.length - 1].toISOString().slice(0, 10);
                const startDate = workDays[0].toISOString().slice(0, 10);
                document.getElementById('range1Start').value = startDate;
                document.getElementById('range1End').value = endDate;
            } else {
                 // Fallback if no work days found
                 const today = new Date();
                 const lastWeek = new Date();
                 lastWeek.setDate(today.getDate() - 7);
                 document.getElementById('range1Start').value = lastWeek.toISOString().slice(0, 10);
                 document.getElementById('range1End').value = today.toISOString().slice(0, 10);
            }

            renderChart();
        }

        /**
         * Opens the modal to manage (rename, re-assign, delete) a reason.
         * @param {string} reason - The reason to manage.
         */
        function openManageReasonModal(reason) {
            const modal = document.getElementById('manageReasonModal');
            document.getElementById('originalReasonInput').value = reason;
            document.getElementById('renameReasonInput').value = reason;
            const select = document.getElementById('reassignReasonSelect'); select.innerHTML = '';
            // Populate dropdown with *other* reasons
            lowQualityReasons.filter(r => r !== reason).forEach(r => { const option = document.createElement('option'); option.value = r; option.textContent = r; select.appendChild(option); });
            select.disabled = select.options.length === 0;
            modal.style.display = 'flex';
        }

        /**
         * Renames a reason across all sessions.
         */
        async function handleReasonSave() {
            const originalReason = document.getElementById('originalReasonInput').value, newReason = document.getElementById('renameReasonInput').value.trim();
            if (!newReason || newReason === originalReason) return;
            if (lowQualityReasons.includes(newReason)) { showMessage(`Reason "${newReason}" already exists.`); return;
            }
            const batch = writeBatch(db);
            // Update all sessions
            for (const date in focusedTimeData) {
                const sessions = focusedTimeData[date].sessions || [];
                if (sessions.some(s => s.reason === originalReason)) {
                    const updatedSessions = sessions.map(s => s.reason === originalReason ? { ...s, reason: newReason } : s);
                    const docRef = doc(db, `artifacts/${APP_ID_FOR_FIRESTORE}/users/${userId}/focusSessions`, date); batch.update(docRef, { sessions: updatedSessions });
                }
            }
            // Update the master list of reasons
            const reasonsDocRef = doc(db, `artifacts/${APP_ID_FOR_FIRESTORE}/users/${userId}/reflectionData/reasons`);
            batch.update(reasonsDocRef, { reasons: arrayRemove(originalReason) }); batch.update(reasonsDocRef, { reasons: arrayUnion(newReason) });
            await batch.commit(); showMessage(`Reason renamed to "${newReason}"`); document.getElementById('manageReasonModal').style.display = 'none';
        }
        
        /**
         * Re-assigns all sessions from one reason to another.
         */
        async function handleReasonReassign() {
            const originalReason = document.getElementById('originalReasonInput').value, targetReason = document.getElementById('reassignReasonSelect').value;
            if (!targetReason) return;
            const batch = writeBatch(db);
            // Update all sessions
            for (const date in focusedTimeData) {
                const sessions = focusedTimeData[date].sessions || [];
                 if (sessions.some(s => s.reason === originalReason)) {
                    const updatedSessions = sessions.map(s => s.reason === originalReason ? { ...s, reason: targetReason } : s);
                    const docRef = doc(db, `artifacts/${APP_ID_FOR_FIRESTORE}/users/${userId}/focusSessions`, date); batch.update(docRef, { sessions: updatedSessions });
                }
            }
            // Remove the old reason from the master list
            const reasonsDocRef = doc(db, `artifacts/${APP_ID_FOR_FIRESTORE}/users/${userId}/reflectionData/reasons`);
            batch.update(reasonsDocRef, { reasons: arrayRemove(originalReason) });
            await batch.commit(); showMessage(`Reason "${originalReason}" was merged into "${targetReason}".`);
            document.getElementById('manageReasonModal').style.display = 'none';
        }

        /**
         * Deletes a reason entirely from all sessions.
         */
        async function handleReasonDelete() {
             const reasonToDelete = document.getElementById('originalReasonInput').value;
             if (!await showConfirm(`Delete reason "${reasonToDelete}" from all entries? This cannot be undone.`)) return;
             const batch = writeBatch(db);
             // Update all sessions, setting reason to null
             for (const date in focusedTimeData) {
                const sessions = focusedTimeData[date].sessions || [];
                 if (sessions.some(s => s.reason === reasonToDelete)) {
                    const updatedSessions = sessions.map(s => s.reason === reasonToDelete ? { ...s, reason: null } : s);
                    const docRef = doc(db, `artifacts/${APP_ID_FOR_FIRESTORE}/users/${userId}/focusSessions`, date); batch.update(docRef, { sessions: updatedSessions });
                }
            }
            // Remove from master list
            const reasonsDocRef = doc(db, `artifacts/${APP_ID_FOR_FIRESTORE}/users/${userId}/reflectionData/reasons`);
            batch.update(reasonsDocRef, { reasons: arrayRemove(reasonToDelete) });
            await batch.commit(); showMessage(`Reason "${reasonToDelete}" was deleted.`); document.getElementById('manageReasonModal').style.display = 'none';
        }

        /**
         * Schedules a 15-minute "Still focusing?" notification.
         */
        function scheduleNextNotification() {
            if (notificationTimeoutId) clearTimeout(notificationTimeoutId);
            if (!notificationsEnabled || !running) return;
            notificationTimeoutId = setTimeout(() => { if (Notification.permission === 'granted') new Notification('Still focusing?'); scheduleNextNotification() }, 15 * 60 * 1000);
        }

        /**
         * Starts the break timer display.
         */
        function startBreakTimer() {
            stopBreakTimer();
            if (currentTimerMode === 'countdown') {
                const suggestionEl = document.getElementById('breakActivitySuggestion');
                const activities = userSettings.breakActivities || [];
                if (activities.length > 0) {
                    suggestionEl.textContent = `Suggested Activities: ${activities.join(', ')}`;
                    suggestionEl.classList.remove('hidden');
                }
            }
            document.getElementById('breakTimerDisplay').classList.remove('hidden');
            breakStartTime = Date.now();
            breakTimerInterval = setInterval(() => {
                const elapsedSeconds = (Date.now() - breakStartTime) / 1000;
                const minutes = String(Math.floor(elapsedSeconds / 60)).padStart(2, '0');
                const seconds = String(Math.floor(elapsedSeconds % 60)).padStart(2, '0');
                document.getElementById('breakTimerDisplay').textContent = `Break: ${minutes}:${seconds}`;
             }, 1000);
        }

        /**
         * Stops the break timer display.
         */
        function stopBreakTimer() {
            clearInterval(breakTimerInterval);
            document.getElementById('breakTimerDisplay').classList.add('hidden');
            document.getElementById('breakActivitySuggestion').classList.add('hidden');
        }

        /**
         * Starts the overtime timer in the "Medal" modal.
         */
        function startOvertimeTimer() {
            overtimeStartTime = Date.now();
            overtimeInterval = setInterval(() => {
                const elapsedSeconds = (Date.now() - overtimeStartTime) / 1000;
                document.getElementById('overtimeDisplay').textContent = formatTimer(elapsedSeconds);
            }, 1000);
        }

        /**
         * Opens the settings modal and populates it with user settings.
         */
        function openSettingsModal() {
            document.getElementById('settingsRitualText').value = userSettings.ritual || '';
            document.getElementById('settingsSpotifyLink').value = userSettings.spotifyLink || '';
            document.getElementById('settingsMinSessionLength').value = userSettings.minSessionLength || '';
            renderBreakActivitiesList();
            document.getElementById('settingsModal').style.display = 'flex';
        }
        
        /**
         * Debounces saving settings to Firestore.
         * @param {object} newSettings - The settings object to save.
         * @param {string} statusElId - The ID of the element to show save status.
         */
        function debounceSaveSettings(newSettings, statusElId) {
            const status = document.getElementById(statusElId);
            status.textContent = 'Typing...';
            clearTimeout(settingsSaveTimers[statusElId]);
            settingsSaveTimers[statusElId] = setTimeout(() => {
                saveSettings(newSettings);
                status.textContent = 'Saved!';
                setTimeout(() => status.textContent = '', 2000);
            }, 1000);
        }

        /**
         * Saves settings to Firestore.
         * @param {object} newSettings - The settings object to save.
         */
        async function saveSettings(newSettings) {
            const settingsDocRef = doc(db, `artifacts/${APP_ID_FOR_FIRESTORE}/users/${userId}/settings/main`);
            await setDoc(settingsDocRef, newSettings, { merge: true });
        }

        /**
         * Renders the list of break activities in the settings modal.
         */
        function renderBreakActivitiesList() {
            const list = document.getElementById('breakActivitiesList');
            list.innerHTML = '';
            (userSettings.breakActivities || []).forEach(activity => {
                const li = document.createElement('li'); li.className = 'flex justify-between items-center p-2 bg-gray-100 rounded';
                li.textContent = activity;
                const deleteBtn = document.createElement('button'); deleteBtn.className = 'text-red-500 hover:text-red-700 font-bold px-2';
                deleteBtn.innerHTML = '×';
                deleteBtn.onclick = () => handleDeleteBreakActivity(activity);
                li.appendChild(deleteBtn);
                list.appendChild(li);
            });
        }
        
        /**
         * Adds a new break activity to user settings.
         */
        async function handleAddBreakActivity() {
            const input = document.getElementById('newBreakActivityInput');
            const newActivity = input.value.trim();
            if (newActivity && !(userSettings.breakActivities || []).includes(newActivity)) {
                await saveSettings({ breakActivities: arrayUnion(newActivity) });
                input.value = '';
                const status = document.getElementById('breakActivitySaveStatus');
                status.textContent = 'Activity added!';
                setTimeout(() => status.textContent = '', 2000);
            }
        }

        /**
         * Deletes a break activity from user settings.
         * @param {string} activity - The activity to remove.
         */
        async function handleDeleteBreakActivity(activity) { 
            await saveSettings({ breakActivities: arrayRemove(activity) });
            const status = document.getElementById('breakActivitySaveStatus');
            status.textContent = 'Activity removed!';
            setTimeout(() => status.textContent = '', 2000);
        }

        /**
         * Sets up the interactive star rating component.
         * @param {HTMLElement} starContainer - The container element for the stars.
         */
        function setupStarRating(starContainer) {
            const stars = starContainer.querySelectorAll('.fa-star');
            starContainer.addEventListener('mouseleave', () => stars.forEach(s => s.classList.remove('hover')));
            stars.forEach(star => {
                star.addEventListener('mouseenter', e => {
                    const rating = e.target.dataset.value;
                    stars.forEach(s => s.classList.toggle('hover', s.dataset.value <= rating));
                });
                star.addEventListener('click', e => {
                    const rating = e.target.dataset.value;
                    starContainer.dataset.rating = rating;
                    stars.forEach(s => s.classList.toggle('selected', s.dataset.value <= rating));
                });
            });
        }

        /**
         * Attempts to launch the Spotify app, with a fallback to the web player.
         */
        function launchSpotify() {
            if (!focusMusicEnabled) return;
            let spotifyUrl = userSettings.spotifyLink || 'https://open.spotify.com/artist/4GLYyR12mcN6csCeLaqSKo1';

            if (spotifyUrl) {
                // Clean up the URL
                spotifyUrl = spotifyUrl.split('?')[0];
                spotifyUrl = spotifyUrl.replace(/\/intl-[a-z]{2}/, '');
            }

            const appUri = spotifyUrl.replace(/https?:\/\/open\.spotify\.com\//, 'spotify:');
            
            // Set a fallback timer
            const fallbackTimeout = setTimeout(() => {
                // If this runs, the app didn't open.
                window.removeEventListener('blur', blurHandler);
                window.removeEventListener('visibilitychange', visibilityChangeHandler);
                window.open(spotifyUrl, '_blank');
            }, 3000); 

            // Handler to clear timeout if app switch is successful
            const blurHandler = () => {
                clearTimeout(fallbackTimeout);
                window.removeEventListener('blur', blurHandler);
                window.removeEventListener('visibilitychange', visibilityChangeHandler);
            };
            
            const visibilityChangeHandler = () => {
                if (document.visibilityState === 'hidden') {
                    clearTimeout(fallbackTimeout);
                    window.removeEventListener('blur', blurHandler);
                    window.removeEventListener('visibilitychange', visibilityChangeHandler);
                }
            };

            window.addEventListener('blur', blurHandler);
            window.addEventListener('visibilitychange', visibilityChangeHandler);
            
            // Attempt to open app URI via iframe
            const iframe = document.createElement('iframe');
            iframe.style.display = 'none';
            iframe.src = appUri;
            document.body.appendChild(iframe);

            // Clean up the iframe and listeners
            setTimeout(() => {
                if (document.body.contains(iframe)) {
                    document.body.removeChild(iframe);
                }
            }, 500);
            
            setTimeout(() => {
                 window.removeEventListener('blur', blurHandler);
                 window.removeEventListener('visibilitychange', visibilityChangeHandler);
            }, 3500);
        }

        // --- Utility Modals ---
        /**
         * Shows a simple message modal.
         * @param {string} msg - The message to display.
         */
        function showMessage(msg) { document.getElementById('modalMessage').textContent = msg; document.getElementById('messageModal').style.display = 'flex'; }
        
        /**
         * Shows a confirmation modal.
         * @param {string} msg - The confirmation message.
         * @returns {Promise<boolean>} A promise that resolves to true (Confirm) or false (Cancel).
         */
        function showConfirm(msg) {
            return new Promise(resolve => {
                const confirmModal = document.getElementById('confirmModal');
                document.getElementById('confirmMessage').textContent = msg;
                confirmModal.style.display = 'flex';
                document.getElementById('confirmOkBtn').onclick = () => { confirmModal.style.display = 'none'; resolve(true); };
                document.getElementById('confirmCancelBtn').onclick = () => { confirmModal.style.display = 'none'; resolve(false); };
            });
        }
    </script>
</body>
</html>
